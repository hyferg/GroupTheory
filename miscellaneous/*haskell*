The next big Haskell project is about to start!
If I break, you can:
  1. Restart:           M-x haskell-process-restart
  2. Configure logging: C-h v haskell-process-log (useful for debugging)
  3. General config:    M-x customize-mode
  4. Hide these tips:   C-h v haskell-process-show-debug-tips
Changed directory: /home/cameron/Documents/git/academic/GroupTheory/miscellaneous/
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )

tensor.hs:20:53-67: error:
    • Couldn't match expected type ‘[Pointer] -> [[a1]]’
                  with actual type ‘[[a0]]’
    • The function ‘tails’ is applied to two arguments,
      but its type ‘[a0] -> [[a0]]’ has only one
      In the expression: tails points (t)
      In a stmt of a list comprehension: (x : ys) <- tails points (t)
   |
20 | doublePoint (Tensor t) = 1 == length [0 | (x:ys) <- tails points(t), y <- ys, x==y]
   |                                                     ^^^^^^^^^^^^^^^

tensor.hs:20:59-64: error:
    • Variable not in scope: points :: [a0]
    • Perhaps you meant ‘print’ (imported from Prelude)
   |
20 | doublePoint (Tensor t) = 1 == length [0 | (x:ys) <- tails points(t), y <- ys, x==y]
   |                                                           ^^^^^^
Failed, no modules loaded.
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )

tensor.hs:20:53-70: error:
    • Couldn't match expected type ‘[Pointer] -> [[a1]]’
                  with actual type ‘[[a0]]’
    • The function ‘tails’ is applied to two arguments,
      but its type ‘[a0] -> [[a0]]’ has only one
      In the expression: tails getPoints (t)
      In a stmt of a list comprehension: (x : ys) <- tails getPoints (t)
   |
20 | doublePoint (Tensor t) = 1 == length [0 | (x:ys) <- tails getPoints(t), y <- ys, x==y]
   |                                                     ^^^^^^^^^^^^^^^^^^

tensor.hs:20:59-67: error:
    • Couldn't match expected type ‘[a0]’
                  with actual type ‘[Pointer] -> [Int]’
    • Probable cause: ‘getPoints’ is applied to too few arguments
      In the first argument of ‘tails’, namely ‘getPoints’
      In the expression: tails getPoints (t)
      In a stmt of a list comprehension: (x : ys) <- tails getPoints (t)
   |
20 | doublePoint (Tensor t) = 1 == length [0 | (x:ys) <- tails getPoints(t), y <- ys, x==y]
   |                                                           ^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> splitAt 1 [0,1,2,3]
([0],[1,2,3])
λ> intersect [1,2,3] [0,2]
[2]
λ> intersect [1,2,3 [1,2]

<interactive>:60:23: error:
    parse error (possibly incorrect indentation or mismatched brackets)
λ> intersect [1,2,3 [1,λ> intersect [1,2,3 [1,λ> 

<interactive>:61:24: error:
    parse error (possibly incorrect indentation or mismatched brackets)
λ> intersect [1,2,3] [1,2]
[1,2]
λ> intersectBy (==) [3,2,1] [1,2]
[2,1]
λ> intersectBy (!=) [3,2,1] [1,2]

<interactive>:64:13-16: error:
    • Variable not in scope: (!=) :: a -> a -> Bool
    • Perhaps you meant one of these:
        ‘>=’ (imported from Prelude), ‘==’ (imported from Prelude),
        ‘/=’ (imported from Prelude)
λ> intersectBy (not ==) [3,2,1] [1,2]

<interactive>:65:14-19: error:
    • Couldn't match type ‘Bool’ with ‘(Bool -> Bool) -> Bool’
      Expected type: (Bool -> Bool) -> (Bool -> Bool) -> Bool
        Actual type: (Bool -> Bool) -> Bool
    • In the first argument of ‘intersectBy’, namely ‘(not ==)’
      In the expression: intersectBy (not ==) [3, 2, 1] [1, 2]
      In an equation for ‘it’: it = intersectBy (not ==) [3, 2, 1] [1, 2]
λ> intersectBy (/=) [3,2,1] [1,2]
[3,2,1]
λ> intersectBy (/=) [1,2] [3,2,1] 
[1,2]
λ> :t filter
filter :: (a -> Bool) -> [a] -> [a]
λ> :t elem
elem :: (Foldable t, Eq a) => a -> t a -> Bool
λ> 1 `elem` [1,2,3]
True
λ> filter (\x = 1) [1,2,3]

<interactive>:71:12: error:
    parse error on input ‘=’
    Perhaps you need a 'let' in a 'do' block?
    e.g. 'let x = 5' instead of 'x = 5'
λ> filter (\x -> 1) [1,2,3]

<interactive>:72:15: error:
    • Could not deduce (Num Bool) arising from the literal ‘1’
      from the context: Num a
        bound by the inferred type of it :: Num a => [a]
        at <interactive>:72:1-24
    • In the expression: 1
      In the first argument of ‘filter’, namely ‘(\ x -> 1)’
      In the expression: filter (\ x -> 1) [1, 2, 3]
λ> filter (\x -> True) [1,2,3]
[1,2,3]
λ> filter (\x -> x `notElem` [2]) [1,2,3]
[2]
λ> filter (\x -> x `notElem` [2]) [1,2,3]
[1,3]
λ> :t zipp

<interactive>:1:1-4: error:
    • Variable not in scope: zipp
    • Perhaps you meant one of these:
        ‘zip’ (imported from Data.List), ‘zip3’ (imported from Data.List),
        ‘zip4’ (imported from Data.List)
λ> :t zip
zip :: [a] -> [b] -> [(a, b)]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> notBubblePointers t3
notBubblePointers t3 :: p -> [Pointer]
λ> notBubblePointers t3 []
[Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (2,1)]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> notBubblePointers t3 [1,2]
[Pointer Gluon (-1,0)]
λ> notBubblePointers t3 [1,2]
[Pointer Gluon (-1,0)]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> t3 `exceptIndices` [0,2]
[Pointer Up (1,2)]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> t3 `exceptIndices` [0,2]
Tensor [Pointer Up (1,2)]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> t3 `pointersExceptIndices` [0,1]
Tensor [Pointer Down (2,1)]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> t3 `pointersExceptIndices` [0,1]
[Pointer Down (2,1)]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )

tensor.hs:25:33: error: parse error on input ‘|’
   |
25 | twinBubbleIndices (Tensor t) = [| () <-]
   |                                 ^
Failed, no modules loaded.
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> doublePointsAt t3
*** Exception: Prelude.head: empty list
λ> doublePointsAt t1
1
λ> doublePointsAt t2λ> doublePointsAt t2λ> 

<interactive>:191:21: error:
    parse error (possibly incorrect indentation or mismatched brackets)
λ> doublePointsAt t2
0
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )

tensor.hs:27:35: error:
    • Couldn't match expected type ‘IndexableObject’
                  with actual type ‘[Pointer]’
    • In the first argument of ‘getPoints’, namely ‘t’
      In the second argument of ‘($)’, namely ‘getPoints t’
      In the expression: tails $ getPoints t
   |
27 |   x | (x:ys) <- tails $ getPoints t, y <- ys, fst x == fst y
   |                                   ^
Failed, no modules loaded.
λ> t1

<interactive>:196:1-2: error: Variable not in scope: t1
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )

tensor.hs:28:37: error: parse error on input ‘]’
   |
28 |                                     ]
   |                                     ^
Failed, no modules loaded.
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )

tensor.hs:29:50-71: error:
    Variable not in scope:
      doublePointsSubIndices :: IndexableObject -> b
   |
29 | doublePointInfo (Tensor t) = (doublePointsAt t3, doublePointsSubIndices t3)
   |                                                  ^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> getPoints $ pointers t1

<interactive>:200:13-23: error:
    • Couldn't match expected type ‘IndexableObject’
                  with actual type ‘[Pointer]’
    • In the second argument of ‘($)’, namely ‘pointers t1’
      In the expression: getPoints $ pointers t1
      In an equation for ‘it’: it = getPoints $ pointers t1
λ> pointers t1
[Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (1,1)]
λ> getPoint $ head $ pointers t1
(-1,0)
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> getPoints t1

<interactive>:204:11-12: error:
    • Couldn't match expected type ‘[Pointer]’
                  with actual type ‘IndexableObject’
    • In the first argument of ‘getPoints’, namely ‘t1’
      In the expression: getPoints t1
      In an equation for ‘it’: it = getPoints t1
λ> pointers t3
[Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (2,1)]
λ> getPoints $ pointers t3
[(-1,0),(1,2),(2,1)]
λ> λ> λ> 

<interactive>:207:4: error:
    parse error (possibly incorrect indentation or mismatched brackets)
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )

tensor.hs:20:24-31: error:
    Variable not in scope: getPoint :: a -> b
   |
20 | getPointsData  t = map getPoint t
   |                        ^^^^^^^^
Failed, no modules loaded.
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> getPointsData t1

<interactive>:210:15-16: error:
    • Couldn't match expected type ‘[Pointer]’
                  with actual type ‘IndexableObject’
    • In the first argument of ‘getPointsData’, namely ‘t1’
      In the expression: getPointsData t1
      In an equation for ‘it’: it = getPointsData t1
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )

tensor.hs:20:57: error:
    • Couldn't match expected type ‘IndexableObject’
                  with actual type ‘[Pointer]’
    • In the first argument of ‘pointers’, namely ‘t’
      In the second argument of ‘($)’, namely ‘pointers t’
      In the expression: map getPointData $ pointers t
   |
20 | getPointsData  (Tensor t) = map getPointData $ pointers t
   |                                                         ^
Failed, no modules loaded.
λ> :t map
map :: (a -> b) -> [a] -> [b]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> getPointsData t1
[(-1,0),(1,2),(1,1)]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> getPointsData t1
[(-1,0),(1,2),(1,1)]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )

tensor.hs:26:39: error:
    • Couldn't match expected type ‘IndexableObject’
                  with actual type ‘[Pointer]’
    • In the first argument of ‘getPointsData’, namely ‘t’
      In the second argument of ‘($)’, namely ‘getPointsData t’
      In the expression: tails $ getPointsData t
   |
26 |   0 | (x:ys) <- tails $ getPointsData t, y <- ys, fst x == fst y]
   |                                       ^
Failed, no modules loaded.
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> doesDoublePoint t1
True
λ> doesDoublePoint t2
True
λ> doesDoublePoint t3
False
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )

tensor.hs:25:25-38: error:
    Variable not in scope: getSpacePoints :: [Pointer] -> [a]
   |
25 |   x | (x:ys) <- tails $ getSpacePoints t, y <- ys, x==y]
   |                         ^^^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> doublePointInfo t2
(0,2)
λ> doublePointInfo t3
*** Exception: Prelude.head: empty list
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> doublePointInfo t2
[(0,2)]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> doublePointInfo t2
[((0,2),(0,1))]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> doublePointInfo t2
[(0,(2,1))]
λ> doesDoublePoint t1
True
λ> doublePointInfo t2
[(0,(2,1))]
λ> doublePointInfo t3
[]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> T

<interactive>:239:1: error: Data constructor not in scope: T
λ> :T
unknown command ':T'
use :? for help.
λ> :info T
data T a = Cons {expon :: Int, coeffs :: [a]}
  	-- Defined in ‘MathObj.LaurentPolynomial’
instance (Eq a, Algebra.ZeroTestable.C a) => Eq (T a)
  -- Defined in ‘MathObj.LaurentPolynomial’
instance Functor T -- Defined in ‘MathObj.LaurentPolynomial’
instance Show a => Show (T a)
  -- Defined in ‘MathObj.LaurentPolynomial’
λ> :T
unknown command ':T'
use :? for help.
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )

tensor.hs:10:34-60: error:
    • Expecting one more argument to ‘T’
      Expected a type, but ‘T’ has kind ‘* -> *’
    • In the type ‘T’
      In the definition of data constructor ‘TensorProduct’
      In the data declaration for ‘VectorSpace’
   |
10 | data VectorSpace = TensorProduct MathObj.LaurentPolynomial.T [IndexableObject] deriving (Show)
   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> T Int

<interactive>:245:1: error:
    Data constructor not in scope: T :: t0 -> t

<interactive>:245:3-5: error: Data constructor not in scope: Int
λ> T [1,2,3]

<interactive>:246:1: error:
    Data constructor not in scope: T :: [Integer] -> t
λ> a = T [1,2,3]

<interactive>:247:5: error:
    Data constructor not in scope: T :: [Integer] -> t
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> x = LP.T [1,2,3]

<interactive>:249:5-8: error:
    Not in scope: data constructor ‘LP.T’
    No module named ‘LP’ is imported.
λ> :info T
data T a = Cons {expon :: Int, coeffs :: [a]}
  	-- Defined in ‘MathObj.LaurentPolynomial’
instance (Eq a, Algebra.ZeroTestable.C a) => Eq (T a)
  -- Defined in ‘MathObj.LaurentPolynomial’
instance Functor T -- Defined in ‘MathObj.LaurentPolynomial’
instance Show a => Show (T a)
  -- Defined in ‘MathObj.LaurentPolynomial’
λ> x = Cons [1,2,3]

<interactive>:251:10-16: error:
    • Couldn't match expected type ‘Int’ with actual type ‘[Integer]’
    • In the first argument of ‘Cons’, namely ‘[1, 2, 3]’
      In the expression: Cons [1, 2, 3]
      In an equation for ‘x’: x = Cons [1, 2, 3]
λ> x = Const Int [1,2,3]

<interactive>:252:5-9: error:
    • Data constructor not in scope: Const :: t0 -> [Integer] -> t
    • Perhaps you meant one of these:
        ‘Cons’ (imported from MathObj.LaurentPolynomial),
        variable ‘const’ (imported from Prelude),
        variable ‘const’ (imported from MathObj.LaurentPolynomial)

<interactive>:252:11-13: error: Data constructor not in scope: Int
λ> x = Const 1 [1,2,3]

<interactive>:253:5-9: error:
    • Data constructor not in scope: Const :: Integer -> [Integer] -> t
    • Perhaps you meant one of these:
        ‘Cons’ (imported from MathObj.LaurentPolynomial),
        variable ‘const’ (imported from Prelude),
        variable ‘const’ (imported from MathObj.LaurentPolynomial)
λ> x = Cons 1 [1,2,3]
λ> x
LaurentPolynomial.Cons 1 [1,2,3]
λ> :T
unknown command ':T'
use :? for help.
λ> :info T
data T a = Cons {expon :: Int, coeffs :: [a]}
  	-- Defined in ‘MathObj.LaurentPolynomial’
instance (Eq a, Algebra.ZeroTestable.C a) => Eq (T a)
  -- Defined in ‘MathObj.LaurentPolynomial’
instance Functor T -- Defined in ‘MathObj.LaurentPolynomial’
instance Show a => Show (T a)
  -- Defined in ‘MathObj.LaurentPolynomial’
λ> :info LP.T
data T a = Cons {expon :: Int, coeffs :: [a]}
  	-- Defined in ‘MathObj.LaurentPolynomial’
instance (Eq a, Algebra.ZeroTestable.C a) => Eq (T a)
  -- Defined in ‘MathObj.LaurentPolynomial’
instance Functor T -- Defined in ‘MathObj.LaurentPolynomial’
instance Show a => Show (T a)
  -- Defined in ‘MathObj.LaurentPolynomial’
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> x = fromCoeffs [1,1]
λ> x
LaurentPolynomial.Cons 0 [1,1]
λ> vs = TensorProduct x []
λ> cs

<interactive>:263:1-2: error:
    • Variable not in scope: cs
    • Perhaps you meant one of these:
        ‘cos’ (imported from Prelude), ‘vs’ (line 262)
λ> vs
TensorProduct (LaurentPolynomial.Cons 0 [1,1]) []
λ> :info VectorSpace
data VectorSpace a = TensorProduct (T a) [IndexableObject]
  	-- Defined at tensor.hs:10:1
instance Show a => Show (VectorSpace a)
  -- Defined at tensor.hs:10:73
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> vs
TensorProduct (LaurentPolynomial.Cons 0 [1]) [Tensor [Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (1,1)],Tensor [Pointer Gluon (-2,0),Pointer Up (0,2),Pointer Down (0,1)],Tensor [Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (2,1)]]
λ> bubbleInfo vs

<interactive>:268:1-10: error:
    Variable not in scope: bubbleInfo :: VectorSpace Integer -> t
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> bubbleInfo vs
[[(1,(2,1))],[(0,(2,1))],[]]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> bubbleInfo vs
[[(1,(2,1))],[(0,(2,1))],[]]
λ> bubbleInfo vs
[[(1,(2,1))],[(0,(2,1))],[]]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> bubbleInfo vs
[[(1,(2,1))],[(0,(2,1))],[]]
λ> doublePointInfo t1
[(1,(2,1))]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> doublePointInfo t1
[(1,(2,1))]
λ> doublePointInfo t3
[]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> doublePointInfo t3
[]
λ> bubbleInfo vs
[[(1,(2,1))],[(0,(2,1))]]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> bubbleInfo vs
[(1,(2,1)),(0,(2,1))]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> vs
TensorProduct (LaurentPolynomial.Cons 0 [1]) [Tensor [Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (1,1)],Tensor [Pointer Gluon (-2,0),Pointer Up (0,2),Pointer Down (0,1)],Tensor [Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (2,1)]]
λ> Original vs
Original vs :: State (VectorSpace Integer)
λ> vsFull = Original vs
λ> vsFull
vsFull :: State (VectorSpace Integer)
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> vsFull = Original vs
λ> vsFull
Original (TensorProduct (LaurentPolynomial.Cons 0 [1]) [Tensor [Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (1,1)],Tensor [Pointer Gluon (-2,0),Pointer Up (0,2),Pointer Down (0,1)],Tensor [Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (2,1)]])
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> vs
TensorProduct (LaurentPolynomial.Cons 0 [1]) [Tensor [Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (1,1)],Tensor [Pointer Gluon (-2,0),Pointer Up (0,2),Pointer Down (0,1)],Tensor [Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (2,1)]]
λ> popBubble vs

<interactive>:297:11-12: error:
    • Couldn't match expected type ‘State a’
                  with actual type ‘VectorSpace Integer’
    • In the first argument of ‘popBubble’, namely ‘vs’
      In the expression: popBubble vs
      In an equation for ‘it’: it = popBubble vs
    • Relevant bindings include
        it :: State a (bound at <interactive>:297:1)
λ> vsFull = New vs
λ> popBubble vsFull
New (TensorProduct (LaurentPolynomial.Cons 0 [1]) [Tensor [Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (1,1)],Tensor [Pointer Gluon (-2,0),Pointer Up (0,2),Pointer Down (0,1)],Tensor [Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (2,1)]])
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )

tensor.hs:33:48-77: error:
    • Couldn't match expected type ‘T a -> [IndexableObject] -> t’
                  with actual type ‘State
                                      (T a0 -> [IndexableObject] -> VectorSpace a0)’
    • The function ‘New’ is applied to three arguments,
      but its type ‘(T a0 -> [IndexableObject] -> VectorSpace a0)
                    -> State (T a0 -> [IndexableObject] -> VectorSpace a0)’
      has only one
      In the expression: New TensorProduct poly tensors
      In an equation for ‘popBubble’:
          popBubble (New (TensorProduct poly tensors))
            = New TensorProduct poly tensors
    • Relevant bindings include
        poly :: T a (bound at tensor.hs:33:31)
        popBubble :: State (VectorSpace a) -> t (bound at tensor.hs:33:1)
   |
33 | popBubble (New (TensorProduct poly tensors)) = New TensorProduct poly tensors
   |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> bubbleInfo t1

<interactive>:303:12-13: error:
    • Couldn't match expected type ‘VectorSpace a0’
                  with actual type ‘IndexableObject’
    • In the first argument of ‘bubbleInfo’, namely ‘t1’
      In the expression: bubbleInfo t1
      In an equation for ‘it’: it = bubbleInfo t1
λ> t1
Tensor [Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (1,1)]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )

tensor.hs:22:1-9: error: Not in scope: data constructor ‘PointData’
   |
22 | PointData (Pointer _ a) = a
   | ^^^^^^^^^

tensor.hs:23:1-10: error:
    Not in scope: data constructor ‘PointsData’
   |
23 | PointsData t = map PointData t
   | ^^^^^^^^^^

tensor.hs:25:1-15: error:
    Not in scope: data constructor ‘DoublePointInfo’
   |
25 | DoublePointInfo (Tensor t) = [
   | ^^^^^^^^^^^^^^^

tensor.hs:25:25: error:
    Multiple declarations of ‘t’
    Declared at: tensor.hs:23:12
                 tensor.hs:25:25
   |
25 | DoublePointInfo (Tensor t) = [
   |                         ^
Failed, no modules loaded.
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> doublePointInfo t3
[]
λ> doublePointInfo 51

<interactive>:313:17-18: error:
    • No instance for (Num IndexableObject)
        arising from the literal ‘51’
    • In the first argument of ‘doublePointInfo’, namely ‘51’
      In the expression: doublePointInfo 51
      In an equation for ‘it’: it = doublePointInfo 51
λ> doublePointInfo t1
[(1,(2,1))]
λ> doublePointInfo t2
[(0,(2,1))]
λ> bubbleInfo t1

<interactive>:316:12-13: error:
    • Couldn't match expected type ‘VectorSpace a0’
                  with actual type ‘IndexableObject’
    • In the first argument of ‘bubbleInfo’, namely ‘t1’
      In the expression: bubbleInfo t1
      In an equation for ‘it’: it = bubbleInfo t1
λ> bubbleInfo vs
[(1,(2,1)),(0,(2,1))]
λ> bubbleInfo t1

<interactive>:320:12-13: error:
    • Couldn't match expected type ‘VectorSpace a0’
                  with actual type ‘IndexableObject’
    • In the first argument of ‘bubbleInfo’, namely ‘t1’
      In the expression: bubbleInfo t1
      In an equation for ‘it’: it = bubbleInfo t1
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> bubbleInfo t1

<interactive>:322:12-13: error:
    • Couldn't match expected type ‘VectorSpace a0’
                  with actual type ‘IndexableObject’
    • In the first argument of ‘bubbleInfo’, namely ‘t1’
      In the expression: bubbleInfo t1
      In an equation for ‘it’: it = bubbleInfo t1
λ> doublePointInfo t2
[(0,(2,1))]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> doublePointInfo t1
[(1,(2,1))]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> doublePointInfo t1
[1]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> doublePointInfo t1
[(1,2)]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> doublePointInfo t1
[(1,(2,1))]
λ> doublePointInfo t1
[(1,(2,1))]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> doublePointInfo t1
[((1,2),(2,1))]
λ> doublePoint t2

<interactive>:402:1-11: error:
    Variable not in scope: doublePoint :: IndexableObject -> t
λ> doublePointInfo t2
[((0,2),(2,1))]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> doublePoint t2

<interactive>:405:1-11: error:
    Variable not in scope: doublePoint :: IndexableObject -> t
λ> doublePointInfo t1
[(1,(2,1))]
λ> doublePointInfo t2
[(0,(2,1))]
λ> a =(1,2)
λ> b = (3)
λ> b ++ a

<interactive>:417:6: error:
    • Couldn't match expected type ‘[a]’
                  with actual type ‘(Integer, Integer)’
    • In the second argument of ‘(++)’, namely ‘a’
      In the expression: b ++ a
      In an equation for ‘it’: it = b ++ a
    • Relevant bindings include
        it :: [a] (bound at <interactive>:417:1)
λ> b + a

<interactive>:418:1-5: error:
    • Non type-variable argument in the constraint: Num (a, b)
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        it :: forall a b. (Num a, Num b, Num (a, b)) => (a, b)
λ> prepend b a

<interactive>:419:1-7: error:
    Variable not in scope:
      prepend :: Integer -> (Integer, Integer) -> t
λ> a 
(1,2)
λ> b
3
λ> b = (3,)

<interactive>:422:5-8: error:
    Illegal tuple section: use TupleSections
λ> b = (3,)

Some flags have not been recognized: prompt2, 
*Main| *Main| *Main| 
<interactive>:439:5-8: error:
    Illegal tuple section: use TupleSections
Some flags have not been recognized: prompt2, λ| 
λ> 
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> doublePointInfo t1
[]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> doublePointInfox t1
[]
λ> take 3 [0,1..]
[0,1,2]
λ> zip [0,1..] (points t1)

<interactive>:451:14-19: error:
    • Variable not in scope: points :: IndexableObject -> [b]
    • Perhaps you meant one of these:
        ‘print’ (imported from Prelude), ‘pointers’ (line 16)
λ> points t1

<interactive>:452:1-6: error:
    • Variable not in scope: points :: IndexableObject -> t
    • Perhaps you meant one of these:
        ‘print’ (imported from Prelude), ‘pointers’ (line 16)
λ> pointers t1
[Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (1,1)]
λ> zip [0,1,..] pointers t1

<interactive>:455:10-11: error: parse error on input ‘..’
λ> zip [0,1..] pointers t1

<interactive>:456:1-23: error:
    • Couldn't match expected type ‘IndexableObject -> t’
                  with actual type ‘[(Integer, b0)]’
    • The function ‘zip’ is applied to three arguments,
      but its type ‘[Integer] -> [b0] -> [(Integer, b0)]’ has only two
      In the expression: zip [0, 1 .. ] pointers t1
      In an equation for ‘it’: it = zip [0, 1 .. ] pointers t1
    • Relevant bindings include it :: t (bound at <interactive>:456:1)

<interactive>:456:13-20: error:
    • Couldn't match expected type ‘[b0]’
                  with actual type ‘IndexableObject -> [Pointer]’
    • Probable cause: ‘pointers’ is applied to too few arguments
      In the second argument of ‘zip’, namely ‘pointers’
      In the expression: zip [0, 1 .. ] pointers t1
      In an equation for ‘it’: it = zip [0, 1 .. ] pointers t1
λ> zip [0,1..] (pointers t1)
[(0,Pointer Gluon (-1,0)),(1,Pointer Up (1,2)),(2,Pointer Down (1,1))]
λ> zip [0,1..] (pointersData $ pointers t1)

<interactive>:458:14-25: error:
    • Variable not in scope: pointersData :: [Pointer] -> [b]
    • Perhaps you meant one of these:
        ‘pointsData’ (line 23), ‘pointData’ (line 22)
λ> zip [0,1..] (pointsData $ pointers t1)
[(0,(-1,0)),(1,(1,2)),(2,(1,1))]
λ> tails $ zip [0,1..] (pointsData $ pointers t1)
[[(0,(-1,0)),(1,(1,2)),(2,(1,1))],[(1,(1,2)),(2,(1,1))],[(2,(1,1))],[]]
λ> a = (1,(2,3))
λ> snd $ snd a
3
λ> fst $ snd a
2
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> doublePointInfo t1
[(1,[(1,2)])]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> doublePointInfo t1
[(1,[(1,2),(2,1)])]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> doublePointInfo t1
[(1,[(1,2),(2,1)])]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> doublePointInfo t1
[(1,[(1,2),(2,1)])]
λ> doublePointInfo t2
[(0,[(1,2),(2,1)])]
λ> doublePointInfo t3
[]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> x = map doublePointInfo [t1,t2,t3]
λ> x
[[(1,[(1,2),(2,1)])],[(0,[(1,2),(2,1)])],[]]
λ> x = fst $ map doublePointInfo [t1,t2,t3]

<interactive>:618:11-40: error:
    • Couldn't match expected type ‘(a, b0)’
                  with actual type ‘[[(Int, [(Integer, Int)])]]’
    • In the second argument of ‘($)’, namely
        ‘map doublePointInfo [t1, t2, t3]’
      In the expression: fst $ map doublePointInfo [t1, t2, t3]
      In an equation for ‘x’: x = fst $ map doublePointInfo [t1, t2, t3]
    • Relevant bindings include x :: a (bound at <interactive>:618:1)
λ> x = head $ map doublePointInfo [t1,t2,t3]
λ> x
[(1,[(1,2),(2,1)])]
λ> popBubbleTensors [t3]

<interactive>:691:1-16: error:
    Variable not in scope: popBubbleTensors :: [IndexableObject] -> t
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> popBubbleTensors [t3]
[Tensor [Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (2,1)]]
λ> head $ map doublePointInfo t3

<interactive>:694:28-29: error:
    • Couldn't match expected type ‘[IndexableObject]’
                  with actual type ‘IndexableObject’
    • In the second argument of ‘map’, namely ‘t3’
      In the second argument of ‘($)’, namely ‘map doublePointInfo t3’
      In the expression: head $ map doublePointInfo t3
λ> doublePointInfo t3
[]
λ> head $ map doublePointInfo [t3]
[]
λ> popBubbleTensors [t3]
[Tensor [Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (2,1)]]
λ> popBubbleTensors [t3]
[Tensor [Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (2,1)]]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> popBubbleTensors [t3]
Original [Tensor [Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (2,1)]]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> info = doublePointInfo t1
λ> info
[(1,[(1,2),(2,1)])]
λ> reduced = pointersExceptIndices t1 [1,2]
λ> reduced
[Pointer Gluon (-1,0)]
λ> snd info

<interactive>:724:5-8: error:
    • Couldn't match expected type ‘(a0, b)’
                  with actual type ‘[(Int, [(Integer, Int)])]’
    • In the first argument of ‘snd’, namely ‘info’
      In the expression: snd info
      In an equation for ‘it’: it = snd info
    • Relevant bindings include it :: b (bound at <interactive>:724:1)
λ> info = doublePointInfo t1
λ> info
[(1,[(1,2),(2,1)])]
λ> info = doublePointInfo t2
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )

tensor.hs:51:9-25: error:
    • Couldn't match expected type ‘[a1]’
                  with actual type ‘(Int, [(Integer, Int)])’
    • In the second argument of ‘($)’, namely ‘doublePointInfo x’
      In the expression: head $ doublePointInfo x
      In the expression:
        [head $ doublePointInfo x |
           x <- tensors, not (null $ doublePointInfo x)]
    • Relevant bindings include
        bubbleInfo :: VectorSpace a -> [a1] (bound at tensor.hs:50:1)
   |
51 |  head $ doublePointInfo x | x <- tensors,
   |         ^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> doublePointInfo t2
(0,[(1,2),(2,1)])
λ> snd $ doublePointInfo t2
[(1,2),(2,1)]
λ> info = doublePointInfo t1
λ> info
(1,[(1,2),(2,1)])
λ> [ selfInternalIDX x | x <- snd info ] 
[1,2]
λ> head $ map doublePointInfo [t1, t2]
(1,[(1,2),(2,1)])
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )

tensor.hs:43:11-22: error:
    • Couldn't match expected type ‘[a0]’
                  with actual type ‘(Integer, (Int, [(Integer, Int)]))’
    • In the second argument of ‘(==)’, namely ‘aDoublePoint’
      In the expression: [] == aDoublePoint
      In a stmt of a pattern guard for
                     an equation for ‘popBubbleTensors’:
        [] == aDoublePoint
   |
43 |   | [] == aDoublePoint = Original tensors
   |           ^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )

tensor.hs:43:13-24: error:
    • Couldn't match expected type ‘t0 a0 -> Bool’
                  with actual type ‘(Integer, (Int, [(Integer, Int)]))’
    • In the second argument of ‘(==)’, namely ‘aDoublePoint’
      In the expression: null == aDoublePoint
      In a stmt of a pattern guard for
                     an equation for ‘popBubbleTensors’:
        null == aDoublePoint
   |
43 |   | null == aDoublePoint = Original tensors
   |             ^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )

tensor.hs:43:11-22: error:
    • Couldn't match expected type ‘()’
                  with actual type ‘(Integer, (Int, [(Integer, Int)]))’
    • In the second argument of ‘(==)’, namely ‘aDoublePoint’
      In the expression: () == aDoublePoint
      In a stmt of a pattern guard for
                     an equation for ‘popBubbleTensors’:
        () == aDoublePoint
   |
43 |   | () == aDoublePoint = Original tensors
   |           ^^^^^^^^^^^^
Failed, no modules loaded.
λ> aDoublePoint = head $ zip [0,1..] (map doublePointInfo tensors)

<interactive>:848:40-54: error:
    Variable not in scope: doublePointInfo :: a0 -> b

<interactive>:848:56-62: error:
    Variable not in scope: tensors :: [a0]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )

tensor.hs:43:11-22: error:
    • Couldn't match expected type ‘()’
                  with actual type ‘(Integer, (Int, [(Integer, Int)]))’
    • In the second argument of ‘(==)’, namely ‘aDoublePoint’
      In the expression: () == aDoublePoint
      In a stmt of a pattern guard for
                     an equation for ‘popBubbleTensors’:
        () == aDoublePoint
   |
43 |   | () == aDoublePoint = Original tensors
   |           ^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )

tensor.hs:50:11-22: error:
    • Couldn't match expected type ‘()’
                  with actual type ‘(Integer, (Int, [(Integer, Int)]))’
    • In the second argument of ‘(==)’, namely ‘aDoublePoint’
      In the expression: () == aDoublePoint
      In a stmt of a pattern guard for
                     an equation for ‘popBubbleTensors’:
        () == aDoublePoint
   |
50 |   | () == aDoublePoint = Original tensors
   |           ^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> aDoublePoint = head $ zip [0,1..] (map doublePointInfo [t1,t2,t3])
λ> aDoublePoint
(0,(1,[(1,2),(2,1)]))
λ> aDoublePoint = head $ zip [0,1..] (map doublePointInfo [t3])
λ> aDoublePoint
(0,*** Exception: Prelude.head: empty list
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> aDoublePoint = head $ zip [0,1..] (map doublePointInfo [t3])
λ> aDoublePoint
(0,*** Exception: Prelude.head: empty list
λ> aDoublePoint = zip [0,1..] (map doublePointInfo [t3])
λ> aDoublePoint
[(0,*** Exception: Prelude.head: empty list
λ> zip [0,1,..] []

<interactive>:862:10-11: error: parse error on input ‘..’
λ> zip [0,1..] []
[]
λ> map doublePointInfo [t3]
[*** Exception: Prelude.head: empty list
λ> map doublePointInfo [t3]
[*** Exception: Prelude.head: empty list
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> map doublePointInfo [t3]
[[]]
λ> aDoublePoint = zip [0,1..] (map doublePointInfo [t3])
λ> aDoublePoint
[(0,[])]
λ> aDoublePoint = zip [0,1..] (head $ map doublePointInfo [t3])
λ> aDoublePoint
[]
λ> aDoublePoint = zip [0,1..] (head $ map doublePointInfo [t3])
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> popBubbleTensors [t3]
Original [Tensor [Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (2,1)]]
λ> popBubbleTensors [t1, t3]
*** Exception: tensor.hs:(42,1)-(45,67): Non-exhaustive patterns in function popBubbleTensors

λ> aDoublePoint = zip [0,1..] (head $ map doublePointInfo [t1, t2])
λ> aDoublePoint
[(0,(1,[(1,2),(2,1)]))]
λ> head $ maps doublePointInfo [t1,t2]

<interactive>:886:8-11: error:
    • Variable not in scope:
        maps
          :: (IndexableObject -> [(Int, [(Integer, Int)])])
             -> [IndexableObject] -> [a]
    • Perhaps you meant one of these:
        ‘map’ (imported from Data.List), ‘mapM’ (imported from Prelude)
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> head $ maps doublePointInfo [t1,t2]

<interactive>:891:8-11: error:
    • Variable not in scope:
        maps
          :: (IndexableObject -> [(Int, [(Integer, Int)])])
             -> [IndexableObject] -> [a]
    • Perhaps you meant one of these:
        ‘map’ (imported from Data.List), ‘mapM’ (imported from Prelude)
λ> head $ map doublePointInfo [t1,t2]
[(1,[(1,2),(2,1)])]
λ> head $ map doublePointInfo [t3]
[]
λ> zip [0,1..] (head $ map doublePointInfo [t3])
[]
λ> zip [0,1..] (head $ map doublePointInfo [t3, t1, t2])
[(0,(1,[(1,2),(2,1)]))]
λ> zip [0,1..] (head $ map doublePointInfo [t3, t1, t2])
[]
λ> map doublePointInfo [t3, t2, t1]
[[],[(0,[(1,2),(2,1)])],[(1,[(1,2),(2,1)])]]
λ> doublePointInfo t1
[(1,[(1,2),(2,1)])]
λ> doublePointInfo t3
[]
λ> filter (\x -> x /= []) map doublePointInfo [t3, t2, t1]

<interactive>:901:1-55: error:
    • Couldn't match expected type ‘(IndexableObject
                                     -> [(Int, [(Integer, Int)])])
                                    -> [IndexableObject] -> t’
                  with actual type ‘[[()]]’
    • The function ‘filter’ is applied to four arguments,
      but its type ‘([()] -> Bool) -> [[()]] -> [[()]]’ has only two
      In the expression:
        filter (\ x -> x /= []) map doublePointInfo [t3, t2, t1]
      In an equation for ‘it’:
          it = filter (\ x -> x /= []) map doublePointInfo [t3, t2, t1]
    • Relevant bindings include it :: t (bound at <interactive>:901:1)

<interactive>:901:24-26: error:
    • Couldn't match expected type ‘[[()]]’
                  with actual type ‘(a0 -> b0) -> [a0] -> [b0]’
    • Probable cause: ‘map’ is applied to too few arguments
      In the second argument of ‘filter’, namely ‘map’
      In the expression:
        filter (\ x -> x /= []) map doublePointInfo [t3, t2, t1]
      In an equation for ‘it’:
          it = filter (\ x -> x /= []) map doublePointInfo [t3, t2, t1]
λ> head head $filter (\x -> x /= []) $ map doublePointInfo [t3, t2, t1]
[[(0,[(1,2),(2,1)])],[(1,[(1,2),(2,1)])]]
λ> head head $filter (\x -> x /= []) $ map doublePointInfo [t3, t2, t1]

<interactive>:903:6-9: error:
    • Couldn't match expected type ‘[[[(Int, [(Integer, Int)])]] -> t]’
                  with actual type ‘[a0] -> a0’
    • Probable cause: ‘head’ is applied to too few arguments
      In the first argument of ‘head’, namely ‘head’
      In the expression: head head
      In the expression:
        head head
          $ filter (\ x -> x /= []) $ map doublePointInfo [t3, t2, t1]
    • Relevant bindings include it :: t (bound at <interactive>:903:1)
λ> head head $ filter (\x -> x /= []) $ map doublePointInfo [t3, t2, t1]

<interactive>:904:6-9: error:
    • Couldn't match expected type ‘[[[(Int, [(Integer, Int)])]] -> t]’
                  with actual type ‘[a0] -> a0’
    • Probable cause: ‘head’ is applied to too few arguments
      In the first argument of ‘head’, namely ‘head’
      In the expression: head head
      In the expression:
        head head
          $ filter (\ x -> x /= []) $ map doublePointInfo [t3, t2, t1]
    • Relevant bindings include it :: t (bound at <interactive>:904:1)
λ> head $ head $ filter (\x -> x /= []) $ map doublePointInfo [t3, t2, t1]
(0,[(1,2),(2,1)])
λ> head $ head $ filter (\x -> x /= []) $ map doublePointInfo [t3]
*** Exception: Prelude.head: empty list
λ> head $ filter (\x -> x /= []) $ map doublePointInfo [t3]
*** Exception: Prelude.head: empty list
λ> filter (\x -> x /= []) $ map doublePointInfo [t3]
[]
λ> filter (\x -> x /= []) $ map doublePointInfo [t3, t1]
[[(1,[(1,2),(2,1)])]]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> filter (\x -> x /= []) $ map doublePointInfo [t3, t1]
[[(1,[(1,2),(2,1)])]]
λ> filter (\x -> x /= []) $ map doublePointInfo [t3]
[]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )

tensor.hs:(29,1)-(40,61): error:
    • Non type-variable argument
        in the constraint: Num (Int, [(a, Int)])
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        doublePointInfo :: forall a.
                           (Eq a, Num (Int, [(a, Int)]), Num a, Enum a) =>
                           IndexableObject -> (Int, [(a, Int)])
   |
29 | doublePointInfo (Tensor t) = if (info /= []) then (head info) else (1)
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...

tensor.hs:44:5-22: error:
    • Ambiguous type variable ‘b0’ arising from a use of ‘==’
      prevents the constraint ‘(Eq b0)’ from being solved.
      Probable fix: use a type annotation to specify what ‘b0’ should be.
      These potential instances exist:
        instance (Eq a, Eq b) => Eq (Either a b)
          -- Defined in ‘Data.Either’
        instance Eq Ordering -- Defined in ‘GHC.Classes’
        instance Eq Integer
          -- Defined in ‘integer-gmp-1.0.2.0:GHC.Integer.Type’
        ...plus 24 others
        ...plus 153 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: [] == aDoublePoint
      In a stmt of a pattern guard for
                     an equation for ‘popBubbleTensors’:
        [] == aDoublePoint
      In an equation for ‘popBubbleTensors’:
          popBubbleTensors tensors
            | [] == aDoublePoint = Original tensors
            where
                aDoublePoint = zip [0, 1 .. ] (head $ map doublePointInfo tensors)
   |
44 |   | [] == aDoublePoint = Original tensors
   |     ^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )

tensor.hs:44:5-22: error:
    • Ambiguous type variable ‘a0’ arising from a use of ‘==’
      prevents the constraint ‘(Eq a0)’ from being solved.
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      These potential instances exist:
        instance (Eq a, Eq b) => Eq (Either a b)
          -- Defined in ‘Data.Either’
        instance Eq Ordering -- Defined in ‘GHC.Classes’
        instance Eq Integer
          -- Defined in ‘integer-gmp-1.0.2.0:GHC.Integer.Type’
        ...plus 24 others
        ...plus 153 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: [] == aDoublePoint
      In a stmt of a pattern guard for
                     an equation for ‘popBubbleTensors’:
        [] == aDoublePoint
      In an equation for ‘popBubbleTensors’:
          popBubbleTensors tensors
            | [] == aDoublePoint = Original tensors
            where
                aDoublePoint = zip [0, 1 .. ] (head $ map doublePointInfo tensors)
   |
44 |   | [] == aDoublePoint = Original tensors
   |     ^^^^^^^^^^^^^^^^^^

tensor.hs:46:33-66: error:
    • Couldn't match expected type ‘[b]’
                  with actual type ‘(Int, [(Integer, Int)])’
    • In the second argument of ‘zip’, namely
        ‘(head $ map doublePointInfo tensors)’
      In the expression:
        zip [0, 1 .. ] (head $ map doublePointInfo tensors)
      In an equation for ‘aDoublePoint’:
          aDoublePoint = zip [0, 1 .. ] (head $ map doublePointInfo tensors)
    • Relevant bindings include
        aDoublePoint :: [(a, b)] (bound at tensor.hs:46:5)
   |
46 |     aDoublePoint = zip [0,1..] (head $ map doublePointInfo tensors)
   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )

tensor.hs:43:11-22: error:
    • Couldn't match expected type ‘()’
                  with actual type ‘[(Integer, (Int, [(Integer, Int)]))]’
    • In the second argument of ‘(==)’, namely ‘aDoublePoint’
      In the expression: () == aDoublePoint
      In a stmt of a pattern guard for
                     an equation for ‘popBubbleTensors’:
        () == aDoublePoint
   |
43 |   | () == aDoublePoint = Original tensors
   |           ^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> filter (\x -> x /= []) $ map doublePointInfo [t3]
[]
λ> filter (\x -> x /= []) $ map doublePointInfo [t3, t1]
[[(1,[(1,2),(2,1)])]]
λ> head $ head $ filter (\x -> x /= []) $ map doublePointInfo [t3, t2, t1]
(0,[(1,2),(2,1)])
λ> filter (\x -> x /= []) $ map doublePointInfo [t3, t2, t1]
[[(0,[(1,2),(2,1)])],[(1,[(1,2),(2,1)])]]
λ> filter (\x -> x /= []) $ map doublePointInfo [t3]
[]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> popBubbleTensors [t3[

<interactive>:977:22: error:
    parse error (possibly incorrect indentation or mismatched brackets)
λ> popBubbleTensors [t3]
Original [Tensor [Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (2,1)]]
λ> popBubbleTensors [t1, t3]
*** Exception: tensor.hs:(42,1)-(45,71): Non-exhaustive patterns in function popBubbleTensors

λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )

tensor.hs:48:37: error:
    • Found hole: _ :: State [IndexableObject]
    • In the expression: _
      In the expression: if aDoublePoint /= [] then New tensors else _
      In an equation for ‘newTensors’:
          newTensors = if aDoublePoint /= [] then New tensors else _
    • Relevant bindings include
        newTensors :: State [IndexableObject] (bound at tensor.hs:47:5)
        aDoublePoint :: [[(Int, [(Integer, Int)])]]
          (bound at tensor.hs:46:5)
        tensors :: [IndexableObject] (bound at tensor.hs:42:18)
        popBubbleTensors :: [IndexableObject] -> State [IndexableObject]
          (bound at tensor.hs:42:1)
      Valid substitutions include
        undefined :: forall (a :: TYPE r).
                     GHC.Stack.Types.HasCallStack =>
                     a
          (imported from ‘Prelude’ at tensor.hs:1:1
           (and originally defined in ‘GHC.Err’))
   |
48 |                    New tensors else _
   |                                     ^
Failed, no modules loaded.
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> popBubbleTensors [t1, t3]
New [Tensor [Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (1,1)],Tensor [Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (2,1)]]
λ> filter (\x -> x /= []) $ map doublePointInfo tensors

<interactive>:1050:46-52: error:
    • Variable not in scope: tensors :: [IndexableObject]
    • Perhaps you meant data constructor ‘Tensor’ (line 8)
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> filter (\x -> x /= []) $ map doublePointInfo tensors

<interactive>:1052:46-52: error:
    • Variable not in scope: tensors :: [IndexableObject]
    • Perhaps you meant data constructor ‘Tensor’ (line 8)
λ> filter (\x -> x /= []) $ map doublePointInfo [t1,t2]
[[(1,[(1,2),(2,1)])],[(0,[(1,2),(2,1)])]]
λ> filter (\x -> x /= []) $ map doublePointInfo [t1,t2]
[[(1,[(1,2),(2,1)])],[(0,[(1,2),(2,1)])]]
λ> filter (\x -> x /= []) $ map doublePointInfo [t3,t1,t2]
[[(1,[(1,2),(2,1)])],[(0,[(1,2),(2,1)])]]
λ> map doublePointInfo [t3,t1,t2]
[[],[(1,[(1,2),(2,1)])],[(0,[(1,2),(2,1)])]]
λ> zip [0,1..] $ map doublePointInfo [t3,t1,t2]
[(0,[]),(1,[(1,[(1,2),(2,1)])]),(2,[(0,[(1,2),(2,1)])])]
λ> filter (\x -> snd x \= []) $ zip [0,1..] $ map doublePointInfo [t3,t1,t2]

<interactive>:1083:21-22: error:
    • Variable not in scope:
        (\=) :: [(Int, [(a1, Int)])] -> [a0] -> Bool
    • Perhaps you meant one of these:
        ‘>=’ (imported from Prelude), ‘==’ (imported from Prelude),
        ‘/=’ (imported from Prelude)
λ> filter (\x -> (snd x) \= []) $ zip [0,1..] $ map doublePointInfo [t3,t1,t2]

<interactive>:1084:23-24: error:
    • Variable not in scope:
        (\=) :: [(Int, [(a1, Int)])] -> [a0] -> Bool
    • Perhaps you meant one of these:
        ‘>=’ (imported from Prelude), ‘==’ (imported from Prelude),
        ‘/=’ (imported from Prelude)
λ> filter (\x -> (snd x) \= []) zip [0,1..] $ map doublePointInfo [t3,t1,t2]

<interactive>:1085:1-40: error:
    • Couldn't match expected type ‘[Integer]
                                    -> [[(Int, [(Integer, Int)])]] -> t’
                  with actual type ‘[(a1, t0)]’
    • The function ‘filter’ is applied to three arguments,
      but its type ‘((a1, t0) -> Bool) -> [(a1, t0)] -> [(a1, t0)]’
      has only two
      In the expression: filter (\ x -> (\=) (snd x) []) zip [0, 1 .. ]
      In the expression:
        filter (\ x -> (\=) (snd x) []) zip [0, 1 .. ]
          $ map doublePointInfo [t3, t1, t2]
    • Relevant bindings include it :: t (bound at <interactive>:1085:1)

<interactive>:1085:23-24: error:
    • Variable not in scope: (\=) :: t0 -> [a2] -> Bool
    • Perhaps you meant one of these:
        ‘>=’ (imported from Prelude), ‘==’ (imported from Prelude),
        ‘/=’ (imported from Prelude)

<interactive>:1085:30-32: error:
    • Couldn't match expected type ‘[(a1, t0)]’
                  with actual type ‘[a0] -> [b0] -> [(a0, b0)]’
    • Probable cause: ‘zip’ is applied to too few arguments
      In the second argument of ‘filter’, namely ‘zip’
      In the expression: filter (\ x -> (\=) (snd x) []) zip [0, 1 .. ]
      In the expression:
        filter (\ x -> (\=) (snd x) []) zip [0, 1 .. ]
          $ map doublePointInfo [t3, t1, t2]
λ> x = zip [0,1..] $ map doublePointInfo [t3,t1,t2]
λ> x
[(0,[]),(1,[(1,[(1,2),(2,1)])]),(2,[(0,[(1,2),(2,1)])])]
λ> filter (\x -> [] /= snd x) x
[(1,[(1,[(1,2),(2,1)])]),(2,[(0,[(1,2),(2,1)])])]
λ> filter (\x -> (snd x) \= []) x

<interactive>:1089:23-24: error:
    • Variable not in scope:
        (\=) :: [(Int, [(a2, Int)])] -> [a0] -> Bool
    • Perhaps you meant one of these:
        ‘>=’ (imported from Prelude), ‘==’ (imported from Prelude),
        ‘/=’ (imported from Prelude)
λ> filter (\x -> [] /= snd x) zip [0,1..] $ map doublePointInfo [t3,t1,t2]

<interactive>:1090:1-38: error:
    • Couldn't match expected type ‘[Integer]
                                    -> [[(Int, [(Integer, Int)])]] -> t’
                  with actual type ‘[(a1, [()])]’
    • The function ‘filter’ is applied to three arguments,
      but its type ‘((a1, [()]) -> Bool) -> [(a1, [()])] -> [(a1, [()])]’
      has only two
      In the expression: filter (\ x -> [] /= snd x) zip [0, 1 .. ]
      In the expression:
        filter (\ x -> [] /= snd x) zip [0, 1 .. ]
          $ map doublePointInfo [t3, t1, t2]
    • Relevant bindings include it :: t (bound at <interactive>:1090:1)

<interactive>:1090:28-30: error:
    • Couldn't match expected type ‘[(a1, [()])]’
                  with actual type ‘[a0] -> [b0] -> [(a0, b0)]’
    • Probable cause: ‘zip’ is applied to too few arguments
      In the second argument of ‘filter’, namely ‘zip’
      In the expression: filter (\ x -> [] /= snd x) zip [0, 1 .. ]
      In the expression:
        filter (\ x -> [] /= snd x) zip [0, 1 .. ]
          $ map doublePointInfo [t3, t1, t2]
λ> filter (\x -> [] /= snd x) (zip [0,1..] $ map doublePointInfo [t3,t1,t2])
[(1,[(1,[(1,2),(2,1)])]),(2,[(0,[(1,2),(2,1)])])]
λ> filter (\x -> [] /= snd x) $ zip [0,1..] $ map doublePointInfo [t3,t1,t2]
[(1,[(1,[(1,2),(2,1)])]),(2,[(0,[(1,2),(2,1)])])]
λ> filter (\x -> [] /= snd x) $ zip [0,1..] $ map doublePointInfo [t3]
[]
λ> filter (\x -> [] /= snd x) $ zip [0,1..] $ map doublePointInfo [t3,t1,t2]
[(1,[(1,[(1,2),(2,1)])]),(2,[(0,[(1,2),(2,1)])])]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )

tensor.hs:56:1: error:
    parse error (possibly incorrect indentation or mismatched brackets)
   |
56 | t1 = Tensor [Pointer Gluon (-1,0), Pointer Up (1,2), Pointer Down (1,1)]
   | ^
Failed, no modules loaded.
λ> filter (\x -> [] /= snd x) $ zip [0,1..] $ map doublePointInfo tensors

<interactive>:1186:48-62: error:
    Variable not in scope: doublePointInfo :: a0 -> [a1]

<interactive>:1186:64-70: error:
    Variable not in scope: tensors :: [a0]
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )

tensor.hs:56:1: error:
    parse error (possibly incorrect indentation or mismatched brackets)
   |
56 | t1 = Tensor [Pointer Gluon (-1,0), Pointer Up (1,2), Pointer Down (1,1)]
   | ^
Failed, no modules loaded.
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )

tensor.hs:62:1: error:
    parse error (possibly incorrect indentation or mismatched brackets)
   |
62 | t1 = Tensor [Pointer Gluon (-1,0), Pointer Up (1,2), Pointer Down (1,1)]
   | ^
Failed, no modules loaded.
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> aDoublePoint = head $ filter (\x -> [] /= snd x) $ zip [0,1..] $ map doublePointInfo tensors

<interactive>:1191:86-92: error:
    • Variable not in scope: tensors :: [IndexableObject]
    • Perhaps you meant data constructor ‘Tensor’ (line 8)
λ> aDoublePoint = head $ filter (\x -> [] /= snd x) $ zip [0,1..] $ map doublePointInfo [t1,t2,t3]
λ> aDoublePoint
(0,[(1,[(1,2),(2,1)])])
λ> vs
TensorProduct (LaurentPolynomial.Cons 0 [1]) [Tensor [Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (1,1)],Tensor [Pointer Gluon (-2,0),Pointer Up (0,2),Pointer Down (0,1)],Tensor [Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (2,1)]]
λ> aDoublePoint = head $ filter (\x -> [] /= snd x) $ zip [0,1..] $ map doublePointInfo vs

<interactive>:1196:86-87: error:
    • Couldn't match expected type ‘[IndexableObject]’
                  with actual type ‘VectorSpace Integer’
    • In the second argument of ‘map’, namely ‘vs’
      In the second argument of ‘($)’, namely ‘map doublePointInfo vs’
      In the second argument of ‘($)’, namely
        ‘zip [0, 1 .. ] $ map doublePointInfo vs’
λ> vs
TensorProduct (LaurentPolynomial.Cons 0 [1]) [Tensor [Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (1,1)],Tensor [Pointer Gluon (-2,0),Pointer Up (0,2),Pointer Down (0,1)],Tensor [Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (2,1)]]
lλ> lλ> 

<interactive>:1237:5: error:
    parse error (possibly incorrect indentation or mismatched brackets)
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> aDoublePoint = head $ filter (\x -> [] /= snd x) $ zip [0,1..] $ map doublePointInfo $ tensors vs
λ> aDoublePoint
(0,[(1,[(1,2),(2,1)])])
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> 
λ> aDoublePoint = head $ filter (\x -> [] /= snd x) $ zip [0,1..] $ map doublePointInfo $ tensorsOf vs
λ> (tensorsOf vs) !! (head aDoublePoint)

<interactive>:1247:25-36: error:
    • Couldn't match expected type ‘[Int]’
                  with actual type ‘(Integer, [(Int, [(Integer, Int)])])’
    • In the first argument of ‘head’, namely ‘aDoublePoint’
      In the second argument of ‘(!!)’, namely ‘(head aDoublePoint)’
      In the expression: (tensorsOf vs) !! (head aDoublePoint)
λ> head aDoublePoint

<interactive>:1249:6-17: error:
    • Couldn't match expected type ‘[a]’
                  with actual type ‘(Integer, [(Int, [(Integer, Int)])])’
    • In the first argument of ‘head’, namely ‘aDoublePoint’
      In the expression: head aDoublePoint
      In an equation for ‘it’: it = head aDoublePoint
    • Relevant bindings include it :: a (bound at <interactive>:1249:1)
λ> aDoublePoint
(0,[(1,[(1,2),(2,1)])])
λ> (tensorsOf vs) !! (fst aDoublePoint)
Tensor [Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (1,1)]
λ> import Data.Map
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> m = singleton 0 "asdf"
λ> m
fromList [(0,"asdf")]
λ> :t m
m :: Num k => Map k [Char]
λ> m
fromList [(0,"asdf")]
λ> :t m
m :: Num k => Map k [Char]
λ> 
λ> insert 1 "one"
insert 1 "one" :: (Ord k, Num k) => Map k [Char] -> Map k [Char]
λ> insert 1 "one" m
fromList [(0,"asdf"),(1,"one")]
λ> k = insert 1 "one" m
λ> k
fromList [(0,"asdf"),(1,"one")]
λ> k = insert 0 "one" m
λ> k
fromList [(0,"one")]
λ> m
fromList [(0,"asdf")]
λ> delete 1 m
fromList [(0,"asdf")]
λ> delete 0 m
fromList []
λ> m
fromList [(0,"asdf")]
λ> :t (>>+)

<interactive>:1:1-5: error:
    • Variable not in scope: >>+
    • Perhaps you meant one of these:
        ‘>>=’ (imported from Prelude), ‘>>’ (imported from Prelude)
λ> :t (>>=)
(>>=) :: Monad m => m a -> (a -> m b) -> m b
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:14:10-20: error:
    • No instance for (Applicative State)
        arising from the superclasses of an instance declaration
    • In the instance declaration for ‘Monad State’
   |
14 | instance Monad State where
   |          ^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:17:17-21: error:
    • Couldn't match type ‘a’ with ‘b’
      ‘a’ is a rigid type variable bound by
        the type signature for:
          (>>=) :: forall a b. State a -> (a -> State b) -> State b
        at tensor-map.hs:16:14-16
      ‘b’ is a rigid type variable bound by
        the type signature for:
          (>>=) :: forall a b. State a -> (a -> State b) -> State b
        at tensor-map.hs:16:14-16
      Expected type: State b
        Actual type: State a
    • In the expression: New x
      In an equation for ‘>>=’: New x >>= f = New x
      In the instance declaration for ‘Monad State’
    • Relevant bindings include
        f :: a -> State b (bound at tensor-map.hs:17:13)
        x :: a (bound at tensor-map.hs:17:7)
        (>>=) :: State a -> (a -> State b) -> State b
          (bound at tensor-map.hs:16:14)
   |
17 |   New x >>= f = New x
   |                 ^^^^^

tensor-map.hs:18:12-18: error:
    • Couldn't match expected type ‘State a’
                  with actual type ‘Maybe a0’
    • In the expression: Nothing
      In an equation for ‘fail’: fail _ = Nothing
      In the instance declaration for ‘Monad State’
    • Relevant bindings include
        fail :: String -> State a (bound at tensor-map.hs:18:3)
   |
18 |   fail _ = Nothing
   |            ^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:14:10-20: error:
    • No instance for (Applicative State)
        arising from the superclasses of an instance declaration
    • In the instance declaration for ‘Monad State’
   |
14 | instance Monad State where
   |          ^^^^^^^^^^^

tensor-map.hs:17:17-21: error:
    • Couldn't match type ‘a’ with ‘b’
      ‘a’ is a rigid type variable bound by
        the type signature for:
          (>>=) :: forall a b. State a -> (a -> State b) -> State b
        at tensor-map.hs:16:14-16
      ‘b’ is a rigid type variable bound by
        the type signature for:
          (>>=) :: forall a b. State a -> (a -> State b) -> State b
        at tensor-map.hs:16:14-16
      Expected type: State b
        Actual type: State a
    • In the expression: New x
      In an equation for ‘>>=’: New x >>= f = New x
      In the instance declaration for ‘Monad State’
    • Relevant bindings include
        f :: a -> State b (bound at tensor-map.hs:17:13)
        x :: a (bound at tensor-map.hs:17:7)
        (>>=) :: State a -> (a -> State b) -> State b
          (bound at tensor-map.hs:16:14)
   |
17 |   New x >>= f = New x
   |                 ^^^^^
Failed, no modules loaded.
λ> :info Monad
class Applicative m => Monad (m :: * -> *) where
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  return :: a -> m a
  fail :: String -> m a
  {-# MINIMAL (>>=) #-}
  	-- Defined in ‘GHC.Base’
instance Monad (Either e) -- Defined in ‘Data.Either’
instance Monad [] -- Defined in ‘GHC.Base’
instance Monad Maybe -- Defined in ‘GHC.Base’
instance Monad IO -- Defined in ‘GHC.Base’
instance Monad ((->) r) -- Defined in ‘GHC.Base’
instance Monoid a => Monad ((,) a) -- Defined in ‘GHC.Base’
λ> :info Monad
class Applicative m => Monad (m :: * -> *) where
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  return :: a -> m a
  fail :: String -> m a
  {-# MINIMAL (>>=) #-}
  	-- Defined in ‘GHC.Base’
instance Monad (Either e) -- Defined in ‘Data.Either’
instance Monad [] -- Defined in ‘GHC.Base’
instance Monad Maybe -- Defined in ‘GHC.Base’
instance Monad IO -- Defined in ‘GHC.Base’
instance Monad ((->) r) -- Defined in ‘GHC.Base’
instance Monoid a => Monad ((,) a) -- Defined in ‘GHC.Base’
λ> :info Monad
class Applicative m => Monad (m :: * -> *) where
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  return :: a -> m a
  fail :: String -> m a
  {-# MINIMAL (>>=) #-}
  	-- Defined in ‘GHC.Base’
instance Monad (Either e) -- Defined in ‘Data.Either’
instance Monad [] -- Defined in ‘GHC.Base’
instance Monad Maybe -- Defined in ‘GHC.Base’
instance Monad IO -- Defined in ‘GHC.Base’
instance Monad ((->) r) -- Defined in ‘GHC.Base’
instance Monoid a => Monad ((,) a) -- Defined in ‘GHC.Base’
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:15:10-20: error:
    Duplicate instance declarations:
      instance Monad Maybe -- Defined at tensor-map.hs:15:10
      instance Monad Maybe -- Defined in ‘GHC.Base’
   |
15 | instance Monad Maybe where  
   |          ^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:14:10-20: error:
    • No instance for (Applicative State)
        arising from the superclasses of an instance declaration
    • In the instance declaration for ‘Monad State’
   |
14 | instance Monad State where
   |          ^^^^^^^^^^^

tensor-map.hs:17:17-21: error:
    • Couldn't match type ‘a’ with ‘b’
      ‘a’ is a rigid type variable bound by
        the type signature for:
          (>>=) :: forall a b. State a -> (a -> State b) -> State b
        at tensor-map.hs:16:14-16
      ‘b’ is a rigid type variable bound by
        the type signature for:
          (>>=) :: forall a b. State a -> (a -> State b) -> State b
        at tensor-map.hs:16:14-16
      Expected type: State b
        Actual type: State a
    • In the expression: New x
      In an equation for ‘>>=’: New x >>= f = New x
      In the instance declaration for ‘Monad State’
    • Relevant bindings include
        f :: a -> State b (bound at tensor-map.hs:17:13)
        x :: a (bound at tensor-map.hs:17:7)
        (>>=) :: State a -> (a -> State b) -> State b
          (bound at tensor-map.hs:16:14)
   |
17 |   New x >>= f = New x
   |                 ^^^^^
Failed, no modules loaded.
λ> 
λ> :t Monad

<interactive>:1:1-5: error: Data constructor not in scope: Monad
λ> :info Monad
class Applicative m => Monad (m :: * -> *) where
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  return :: a -> m a
  fail :: String -> m a
  {-# MINIMAL (>>=) #-}
  	-- Defined in ‘GHC.Base’
instance Monad (Either e) -- Defined in ‘Data.Either’
instance Monad [] -- Defined in ‘GHC.Base’
instance Monad Maybe -- Defined in ‘GHC.Base’
instance Monad IO -- Defined in ‘GHC.Base’
instance Monad ((->) r) -- Defined in ‘GHC.Base’
instance Monoid a => Monad ((,) a) -- Defined in ‘GHC.Base’
λ> :info State

<interactive>:1:1-5: error: Not in scope: ‘State’
λ> :t State

<interactive>:1:1-5: error: Data constructor not in scope: State
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :info State
data State a = Original a | New a 	-- Defined at tensor-map.hs:12:1
instance Show a => Show (State a) -- Defined at tensor-map.hs:12:45
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:14:10-20: error:
    • No instance for (Applicative State)
        arising from the superclasses of an instance declaration
    • In the instance declaration for ‘Monad State’
   |
14 | instance Monad State where
   |          ^^^^^^^^^^^

tensor-map.hs:17:17-21: error:
    • Couldn't match type ‘a’ with ‘b’
      ‘a’ is a rigid type variable bound by
        the type signature for:
          (>>=) :: forall a b. State a -> (a -> State b) -> State b
        at tensor-map.hs:16:14-16
      ‘b’ is a rigid type variable bound by
        the type signature for:
          (>>=) :: forall a b. State a -> (a -> State b) -> State b
        at tensor-map.hs:16:14-16
      Expected type: State b
        Actual type: State a
    • In the expression: New x
      In an equation for ‘>>=’: New x >>= f = New x
      In the instance declaration for ‘Monad State’
    • Relevant bindings include
        f :: a -> State b (bound at tensor-map.hs:17:13)
        x :: a (bound at tensor-map.hs:17:7)
        (>>=) :: State a -> (a -> State b) -> State b
          (bound at tensor-map.hs:16:14)
   |
17 |   New x >>= f = New x
   |                 ^^^^^
Failed, no modules loaded.
λ> :info Applicative
class Functor f => Applicative (f :: * -> *) where
  pure :: a -> f a
  (<*>) :: f (a -> b) -> f a -> f b
  GHC.Base.liftA2 :: (a -> b -> c) -> f a -> f b -> f c
  (*>) :: f a -> f b -> f b
  (<*) :: f a -> f b -> f a
  {-# MINIMAL pure, ((<*>) | liftA2) #-}
  	-- Defined in ‘GHC.Base’
instance Applicative (Either e) -- Defined in ‘Data.Either’
instance Applicative [] -- Defined in ‘GHC.Base’
instance Applicative Maybe -- Defined in ‘GHC.Base’
instance Applicative IO -- Defined in ‘GHC.Base’
instance Applicative ((->) a) -- Defined in ‘GHC.Base’
instance Monoid a => Applicative ((,) a) -- Defined in ‘GHC.Base’
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:16:20-26: error:
    • Couldn't match type ‘a’ with ‘b’
      ‘a’ is a rigid type variable bound by
        the type signature for:
          fmap :: forall a b. (a -> b) -> State a -> State b
        at tensor-map.hs:15:3-6
      ‘b’ is a rigid type variable bound by
        the type signature for:
          fmap :: forall a b. (a -> b) -> State a -> State b
        at tensor-map.hs:15:3-6
      Expected type: State b
        Actual type: State a
    • In the expression: New (x)
      In an equation for ‘fmap’: fmap f (New x) = New (x)
      In the instance declaration for ‘Functor State’
    • Relevant bindings include
        x :: a (bound at tensor-map.hs:16:15)
        f :: a -> b (bound at tensor-map.hs:16:8)
        fmap :: (a -> b) -> State a -> State b
          (bound at tensor-map.hs:15:3)
   |
16 |   fmap f (New x) = New (x)
   |                    ^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:16:20-24: error:
    • Couldn't match type ‘a’ with ‘b’
      ‘a’ is a rigid type variable bound by
        the type signature for:
          fmap :: forall a b. (a -> b) -> State a -> State b
        at tensor-map.hs:15:3-6
      ‘b’ is a rigid type variable bound by
        the type signature for:
          fmap :: forall a b. (a -> b) -> State a -> State b
        at tensor-map.hs:15:3-6
      Expected type: State b
        Actual type: State a
    • In the expression: New x
      In an equation for ‘fmap’: fmap f (New x) = New x
      In the instance declaration for ‘Functor State’
    • Relevant bindings include
        x :: a (bound at tensor-map.hs:16:15)
        f :: a -> b (bound at tensor-map.hs:16:8)
        fmap :: (a -> b) -> State a -> State b
          (bound at tensor-map.hs:15:3)
   |
16 |   fmap f (New x) = New x
   |                    ^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:29:1: error:
    parse error (possibly incorrect indentation or mismatched brackets)
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:14:18-25: error:
    Not in scope: type constructor or class ‘Original’
    A data constructor of that name is in scope; did you mean DataKinds?
   |
14 | instance Functor Original where
   |                  ^^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:18:10-26: warning: [-Wmissing-methods]
    • No explicit implementation for
        either ‘<*>’ or ‘GHC.Base.liftA2’
    • In the instance declaration for ‘Applicative State’
   |
18 | instance Applicative State where
   |          ^^^^^^^^^^^^^^^^^
Ok, one module loaded.
Collecting type info for 1 module(s) ... 

tensor-map.hs:18:10-26: warning: [-Wmissing-methods]
    • No explicit implementation for
        either ‘<*>’ or ‘GHC.Base.liftA2’
    • In the instance declaration for ‘Applicative State’
   |
18 | instance Applicative State where
   |          ^^^^^^^^^^^^^^^^^
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:19:10-26: warning: [-Wmissing-methods]
    • No explicit implementation for
        either ‘<*>’ or ‘liftA2’
    • In the instance declaration for ‘Applicative State’
   |
19 | instance Applicative State where
   |          ^^^^^^^^^^^^^^^^^
Ok, one module loaded.
Collecting type info for 1 module(s) ... 

tensor-map.hs:19:10-26: warning: [-Wmissing-methods]
    • No explicit implementation for
        either ‘<*>’ or ‘liftA2’
    • In the instance declaration for ‘Applicative State’
   |
19 | instance Applicative State where
   |          ^^^^^^^^^^^^^^^^^
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:22:10-20: warning: [-Wmissing-methods]
    • No explicit implementation for
        ‘>>=’
    • In the instance declaration for ‘Monad State’
   |
22 | instance Monad State where
   |          ^^^^^^^^^^^
Ok, one module loaded.
Collecting type info for 1 module(s) ... 

tensor-map.hs:22:10-20: warning: [-Wmissing-methods]
    • No explicit implementation for
        ‘>>=’
    • In the instance declaration for ‘Monad State’
   |
22 | instance Monad State where
   |          ^^^^^^^^^^^
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:24:22-28: error:
    • Couldn't match expected type ‘a -> State b’
                  with actual type ‘State (a -> State b)’
    • The function ‘New’ is applied to two arguments,
      but its type ‘(a -> State b) -> State (a -> State b)’ has only one
      In the expression: New f x
      In an equation for ‘>>=’: Original x >>= f = New f x
    • Relevant bindings include
        f :: a -> State b (bound at tensor-map.hs:24:18)
        x :: a (bound at tensor-map.hs:24:12)
        (>>=) :: State a -> (a -> State b) -> State b
          (bound at tensor-map.hs:24:14)
   |
24 |   Original x >>= f = New f x
   |                      ^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:24:22-30: error:
    • Occurs check: cannot construct the infinite type: b ~ State b
      Expected type: State b
        Actual type: State (State b)
    • In the expression: New (f x)
      In an equation for ‘>>=’: Original x >>= f = New (f x)
      In the instance declaration for ‘Monad State’
    • Relevant bindings include
        f :: a -> State b (bound at tensor-map.hs:24:18)
        (>>=) :: State a -> (a -> State b) -> State b
          (bound at tensor-map.hs:24:14)
   |
24 |   Original x >>= f = New (f x)
   |                      ^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:24:22-30: error:
    • Occurs check: cannot construct the infinite type: b ~ State b
      Expected type: State b
        Actual type: State (State b)
    • In the expression: New (f x)
      In an equation for ‘>>=’: Original x >>= f = New (f x)
      In the instance declaration for ‘Monad State’
    • Relevant bindings include
        f :: a -> State b (bound at tensor-map.hs:24:18)
        (>>=) :: State a -> (a -> State b) -> State b
          (bound at tensor-map.hs:24:14)
   |
24 |   Original x >>= f = New (f x)
   |                      ^^^^^^^^^

tensor-map.hs:25:17: error:
    • Couldn't match expected type ‘State b’ with actual type ‘a’
      ‘a’ is a rigid type variable bound by
        the type signature for:
          (>>=) :: forall a b. State a -> (a -> State b) -> State b
        at tensor-map.hs:24:14-16
    • In the expression: x
      In an equation for ‘>>=’: New x >>= f = x
      In the instance declaration for ‘Monad State’
    • Relevant bindings include
        f :: a -> State b (bound at tensor-map.hs:25:13)
        x :: a (bound at tensor-map.hs:25:7)
        (>>=) :: State a -> (a -> State b) -> State b
          (bound at tensor-map.hs:24:14)
   |
25 |   New x >>= f = x
   |                 ^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:25:17: error:
    • Couldn't match expected type ‘State b’ with actual type ‘a’
      ‘a’ is a rigid type variable bound by
        the type signature for:
          (>>=) :: forall a b. State a -> (a -> State b) -> State b
        at tensor-map.hs:24:14-16
    • In the expression: x
      In an equation for ‘>>=’: New x >>= f = x
      In the instance declaration for ‘Monad State’
    • Relevant bindings include
        f :: a -> State b (bound at tensor-map.hs:25:13)
        x :: a (bound at tensor-map.hs:25:7)
        (>>=) :: State a -> (a -> State b) -> State b
          (bound at tensor-map.hs:24:14)
   |
25 |   New x >>= f = x
   |                 ^
Failed, no modules loaded.
λ> :t (>>=)
(>>=) :: Monad m => m a -> (a -> m b) -> m b
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:24:22-30: error:
    • Occurs check: cannot construct the infinite type: b ~ State b
      Expected type: State b
        Actual type: State (State b)
    • In the expression: New (f x)
      In an equation for ‘>>=’: Original x >>= f = New (f x)
      In the instance declaration for ‘Monad State’
    • Relevant bindings include
        f :: a -> State b (bound at tensor-map.hs:24:18)
        (>>=) :: State a -> (a -> State b) -> State b
          (bound at tensor-map.hs:24:14)
   |
24 |   Original x >>= f = New (f x)
   |                      ^^^^^^^^^

tensor-map.hs:25:17: error:
    • Couldn't match expected type ‘State b’ with actual type ‘a’
      ‘a’ is a rigid type variable bound by
        the type signature for:
          (>>=) :: forall a b. State a -> (a -> State b) -> State b
        at tensor-map.hs:24:14-16
    • In the expression: x
      In an equation for ‘>>=’: New x >>= f = x
      In the instance declaration for ‘Monad State’
    • Relevant bindings include
        f :: a -> State b (bound at tensor-map.hs:25:13)
        x :: a (bound at tensor-map.hs:25:7)
        (>>=) :: State a -> (a -> State b) -> State b
          (bound at tensor-map.hs:24:14)
   |
25 |   New x >>= f = x
   |                 ^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:24:22-30: error:
    • Occurs check: cannot construct the infinite type: b ~ State b
      Expected type: State b
        Actual type: State (State b)
    • In the expression: New (f x)
      In an equation for ‘>>=’: Original x >>= f = New (f x)
      In the instance declaration for ‘Monad State’
    • Relevant bindings include
        f :: a -> State b (bound at tensor-map.hs:24:18)
        (>>=) :: State a -> (a -> State b) -> State b
          (bound at tensor-map.hs:24:14)
   |
24 |   Original x >>= f = New (f x)
   |                      ^^^^^^^^^

tensor-map.hs:25:17: error:
    • Couldn't match expected type ‘State b’ with actual type ‘a’
      ‘a’ is a rigid type variable bound by
        the type signature for:
          (>>=) :: forall a b. State a -> (a -> State b) -> State b
        at tensor-map.hs:24:14-16
    • In the expression: x
      In an equation for ‘>>=’: New x >>= f = x
      In the instance declaration for ‘Monad State’
    • Relevant bindings include
        f :: a -> State b (bound at tensor-map.hs:25:13)
        x :: a (bound at tensor-map.hs:25:7)
        (>>=) :: State a -> (a -> State b) -> State b
          (bound at tensor-map.hs:24:14)
   |
25 |   New x >>= f = x
   |                 ^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:24:22-30: error:
    • Occurs check: cannot construct the infinite type: b ~ State b
      Expected type: State b
        Actual type: State (State b)
    • In the expression: New (f x)
      In an equation for ‘>>=’: Original x >>= f = New (f x)
      In the instance declaration for ‘Monad State’
    • Relevant bindings include
        f :: a -> State b (bound at tensor-map.hs:24:18)
        (>>=) :: State a -> (a -> State b) -> State b
          (bound at tensor-map.hs:24:14)
   |
24 |   Original x >>= f = New (f x)
   |                      ^^^^^^^^^

tensor-map.hs:25:17: error:
    • Couldn't match expected type ‘State b’ with actual type ‘a’
      ‘a’ is a rigid type variable bound by
        the type signature for:
          (>>=) :: forall a b. State a -> (a -> State b) -> State b
        at tensor-map.hs:24:14-16
    • In the expression: x
      In an equation for ‘>>=’: New x >>= f = x
      In the instance declaration for ‘Monad State’
    • Relevant bindings include
        f :: a -> State b (bound at tensor-map.hs:25:13)
        x :: a (bound at tensor-map.hs:25:7)
        (>>=) :: State a -> (a -> State b) -> State b
          (bound at tensor-map.hs:24:14)
   |
25 |   New x >>= f = x
   |                 ^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:26:22-30: error:
    • Occurs check: cannot construct the infinite type: b ~ State b
      Expected type: State b
        Actual type: State (State b)
    • In the expression: New (f x)
      In an equation for ‘>>=’: Original x >>= f = New (f x)
      In the instance declaration for ‘Monad State’
    • Relevant bindings include
        f :: a -> State b (bound at tensor-map.hs:26:18)
        (>>=) :: State a -> (a -> State b) -> State b
          (bound at tensor-map.hs:26:14)
   |
26 |   Original x >>= f = New (f x)
   |                      ^^^^^^^^^

tensor-map.hs:27:17: error:
    • Couldn't match expected type ‘State b’ with actual type ‘a’
      ‘a’ is a rigid type variable bound by
        the type signature for:
          (>>=) :: forall a b. State a -> (a -> State b) -> State b
        at tensor-map.hs:26:14-16
    • In the expression: x
      In an equation for ‘>>=’: New x >>= f = x
      In the instance declaration for ‘Monad State’
    • Relevant bindings include
        f :: a -> State b (bound at tensor-map.hs:27:13)
        x :: a (bound at tensor-map.hs:27:7)
        (>>=) :: State a -> (a -> State b) -> State b
          (bound at tensor-map.hs:26:14)
   |
27 |   New x >>= f = x
   |                 ^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> return 1
1
λ> x = return 1
λ> x
1
λ> :t return
return :: Monad m => a -> m a
λ> :t x
x :: (Monad m, Num a) => m a
λ> return 123
123
λ> x = return 1
λ> x
1
λ> return
return :: Monad m => a -> m a
λ> x = Origiginal 1

<interactive>:1830:5-14: error:
    • Data constructor not in scope: Origiginal :: Integer -> t
    • Perhaps you meant ‘Original’ (line 13)
λ> x = Original 1
λ> x
Original 1
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> return 1
1
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> return 1
1
λ> :t return
return :: Monad m => a -> m a
λ> return 1 >>= stateNew

<interactive>:1847:14-21: error:
    Variable not in scope: stateNew :: Integer -> m b
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> return 1 >>= stateNew
New 1
λ> return 1 >>= stateNew
New 1
λ> 1 >>= stateNew

<interactive>:1923:1-14: error:
    • Non type-variable argument in the constraint: Num (State b)
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        it :: forall b. Num (State b) => State b
λ> return 1 >>= stateNew
New 1
λ> :t (>>=)
(>>=) :: Monad m => m a -> (a -> m b) -> m b
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> plusN 1 10
New 11
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> return 1 >>= plus1
New 2
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> return 1 >>= plusSome
New 4
λ> return 10 >>= plusSome
Original 10
λ> return 10 >>= plusSome
Original 10
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> return 10 >>= plusSome
New 13
λ> return 10 >>= plusSome >>= plusSome
Original 13
λ> return 9 >>= plusSome >>= plusSome
Original 12
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:33:26-37: error: Parse error in pattern: poly
   |
33 | popBubble TensorProduct (poly tensors)
   |                          ^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:33:11-23: error:
    • The constructor ‘TensorProduct’ should have 2 arguments, but has been given none
    • In the pattern: TensorProduct
      In an equation for ‘popBubble’:
          popBubble TensorProduct poly tensors
            | otherwise = Original (TensorProduct (poly tensors))
   |
33 | popBubble TensorProduct poly tensors
   |           ^^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:33:27-38: error: Parse error in pattern: poly
   |
33 | popBubble (TensorProduct (poly tensors))
   |                           ^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:39:1: error:
    parse error (possibly incorrect indentation or mismatched brackets)
   |
39 | plusSome x
   | ^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:19:17: error:
    • Couldn't match expected type ‘State b’ with actual type ‘a’
      ‘a’ is a rigid type variable bound by
        the type signature for:
          (>>=) :: forall a b. State a -> (a -> State b) -> State b
        at tensor-map.hs:18:14-16
    • In the expression: x
      In an equation for ‘>>=’: New x >>= f = x
      In the instance declaration for ‘Monad State’
    • Relevant bindings include
        f :: a -> State b (bound at tensor-map.hs:19:13)
        x :: a (bound at tensor-map.hs:19:7)
        (>>=) :: State a -> (a -> State b) -> State b
          (bound at tensor-map.hs:18:14)
   |
19 |   New x >>= f = x
   |                 ^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> plusSome 1
New 4
λ> plusSome 14λ> plusSome 14λ> 

<interactive>:2157:15: error:
    parse error (possibly incorrect indentation or mismatched brackets)
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> plusSome 1

<interactive>:2159:1-10: error:
    • Non type-variable argument in the constraint: Num (State a)
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        it :: forall a. (Num a, Num (State a)) => a -> State a
λ> plusSome (Original 1) 10
New 10
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> plusSome (Original 1) 10
New 10
λ> x = plusSome (Original 1) 10
λ> x
New 10
λ> plusSome x 10
New 10
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> (Original 1) -: plusSome 10

<interactive>:2171:1-27: error:
    • Non type-variable argument in the constraint: Num (State a)
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        it :: forall a.
              (Num a, Num (State a), Num (State (State a))) =>
              State (State a)
λ> (plusSome (Original 1) 1)
New 1
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> plusSome 1 (plusSome 1 (Original 1))
New 2
λ> (Original 1) -: plusSome 1
New 2
λ> (Original 1) -: plusSome 1 -: plusSome 2
New 2
λ> :t plusSOme

<interactive>:1:1-8: error:
    • Variable not in scope: plusSOme
    • Perhaps you meant ‘plusSome’ (line 24)
λ> :t plusSOme

<interactive>:1:1-8: error:
    • Variable not in scope: plusSOme
    • Perhaps you meant ‘plusSome’ (line 24)
λ> :t plusSome
plusSome :: Num a => a -> State a -> State a
λ> plusSome 1 (Original 1) >>= plusSome 1

<interactive>:2212:1-38: error:
    • Non type-variable argument in the constraint: Num (State b)
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        it :: forall b. (Num b, Num (State b)) => State b
λ> 
plusNone n ( x) = Original (x)
Some flags have not been recognized: prompt2, 
*Main Data.Map| *Main Data.Map| *Main Data.Map| Some flags have not been recognized: prompt2, λ| 
λ> plusSome 1 (Original 1)
New 2
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :t (<*>)
(<*>) :: Applicative f => f (a -> b) -> f a -> f b
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> return 1 >>= *2

<interactive>:2234:14: error: parse error on input ‘*’
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> return 1 >>= plusSome
New 11
λ> return 1 >>= plusSome >>= plusSome
*** Exception: tensor-map.hs:18:3-24: Non-exhaustive patterns in function >>=

λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:9:20-26: error:
    • Couldn't match type ‘a’ with ‘b’
      ‘a’ is a rigid type variable bound by
        the type signature for:
          fmap :: forall a b. (a -> b) -> State a -> State b
        at tensor-map.hs:8:3-6
      ‘b’ is a rigid type variable bound by
        the type signature for:
          fmap :: forall a b. (a -> b) -> State a -> State b
        at tensor-map.hs:8:3-6
      Expected type: State b
        Actual type: State a
    • In the expression: New (x)
      In an equation for ‘fmap’: fmap f (New x) = New (x)
      In the instance declaration for ‘Functor State’
    • Relevant bindings include
        x :: a (bound at tensor-map.hs:9:15)
        f :: a -> b (bound at tensor-map.hs:9:8)
        fmap :: (a -> b) -> State a -> State b (bound at tensor-map.hs:8:3)
  |
9 |   fmap f (New x) = New (x)
  |                    ^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> return 1 >>= plusSome >>= plusSome
*** Exception: tensor-map.hs:17:3-24: Non-exhaustive patterns in function >>=

λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:18:17: error:
    • Couldn't match expected type ‘State b’ with actual type ‘a’
      ‘a’ is a rigid type variable bound by
        the type signature for:
          (>>=) :: forall a b. State a -> (a -> State b) -> State b
        at tensor-map.hs:17:14-16
    • In the expression: x
      In an equation for ‘>>=’: New x >>= f = x
      In the instance declaration for ‘Monad State’
    • Relevant bindings include
        f :: a -> State b (bound at tensor-map.hs:18:13)
        x :: a (bound at tensor-map.hs:18:7)
        (>>=) :: State a -> (a -> State b) -> State b
          (bound at tensor-map.hs:17:14)
   |
18 |   New x >>= f = x
   |                 ^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> return 1 >>= plusSome >>= plusSome
New 21
λ> return 1 >>= plusSome
New 11
λ> :t fmap
fmap :: Functor f => (a -> b) -> f a -> f b
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:8:11-45: error:
    • Illegal type signature in instance declaration:
        fmap :: Functor f => (a -> b) -> f a -> f b
      (Use InstanceSigs to allow this)
    • In the instance declaration for ‘Functor State’
  |
8 |   fmap :: Functor f => (a -> b) -> f a -> f b
  |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:8:11-47: error:
    • Illegal type signature in instance declaration:
        fmap :: (Functor f) => (a -> b) -> f a -> f b
      (Use InstanceSigs to allow this)
    • In the instance declaration for ‘Functor State’
  |
8 |   fmap :: (Functor f) => (a -> b) -> f a -> f b
  |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:8:11-32: error:
    • Illegal type signature in instance declaration:
        fmap :: (a -> b) -> f a -> f b
      (Use InstanceSigs to allow this)
    • In the instance declaration for ‘Functor State’
  |
8 |   fmap :: (a -> b) -> f a -> f b
  |           ^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> pure
pure :: Applicative f => a -> f a
λ> pure 1
1
λ> pure 
pure :: Applicative f => a -> f a
λ> pure 1 1
1
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:9:20-26: error:
    • Couldn't match type ‘a’ with ‘b’
      ‘a’ is a rigid type variable bound by
        the type signature for:
          fmap :: forall a b. (a -> b) -> State a -> State b
        at tensor-map.hs:8:3-6
      ‘b’ is a rigid type variable bound by
        the type signature for:
          fmap :: forall a b. (a -> b) -> State a -> State b
        at tensor-map.hs:8:3-6
      Expected type: State b
        Actual type: State a
    • In the expression: New (x)
      In an equation for ‘fmap’: fmap f (New x) = New (x)
      In the instance declaration for ‘Functor State’
    • Relevant bindings include
        x :: a (bound at tensor-map.hs:9:15)
        f :: a -> b (bound at tensor-map.hs:9:8)
        fmap :: (a -> b) -> State a -> State b (bound at tensor-map.hs:8:3)
  |
9 |   fmap f (New x) = New (x)
  |                    ^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> fmap plusSome (Original 1)
New 11
λ> :t fmap
fmap :: Functor f => (a -> b) -> f a -> f b
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> return 1

<interactive>:2371:1-6: error:
    Ambiguous occurrence ‘return’
    It could refer to either ‘Prelude.return’,
                             imported from ‘Prelude’ at tensor-map.hs:1:1
                             (and originally defined in ‘GHC.Base’)
                          or ‘Main.return’, defined at tensor-map.hs:14:3
λ> Main.return 1
Main.return 1 :: (Thing t, Num a) => t a
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:18:3-9: error:
    ‘lreturn’ is not a (visible) method of class ‘Thing’
   |
18 |   lreturn x = Original x
   |   ^^^^^^^
Failed, no modules loaded.
λ> Main.return

<interactive>:2377:1-11: error:
    Not in scope: ‘Main.return’
    No module named ‘Main’ is imported.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> Main.return
Main.return :: Thing t => a -> t a
λ> Main.return 123
Main.return 123 :: (Thing t, Num a) => t a
λ> Main.return 123 123

<interactive>:2383:1-19: error:
    • Could not deduce (Thing ((->) Integer))
        arising from a use of ‘Main.return’
      from the context: Num t
        bound by the inferred type of it :: Num t => t
        at <interactive>:2383:1-19
    • In the expression: Main.return 123 123
      In an equation for ‘it’: it = Main.return 123 123
λ> (Main.return 123) 123

<interactive>:2384:1-21: error:
    • Could not deduce (Thing ((->) Integer))
        arising from a use of ‘Main.return’
      from the context: Num t
        bound by the inferred type of it :: Num t => t
        at <interactive>:2384:1-21
    • In the expression: (Main.return 123) 123
      In an equation for ‘it’: it = (Main.return 123) 123
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> lreturn 1
lreturn 1 :: (Thing t, Num a) => t a
λ> x = lreturn 1
λ> x
x :: (Thing t, Num a) => t a
λ> x + 1
x + 1 :: (Thing t, Num a, Num (t a)) => t a
λ> x = Original x

<interactive>:2393:5-14: error:
    • Occurs check: cannot construct the infinite type: a ~ State a
    • In the expression: Original x
      In an equation for ‘x’: x = Original x
    • Relevant bindings include x :: a (bound at <interactive>:2393:1)
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> x = Original x

<interactive>:2395:5-14: error:
    • Occurs check: cannot construct the infinite type: a ~ State a
    • In the expression: Original x
      In an equation for ‘x’: x = Original x
    • Relevant bindings include x :: a (bound at <interactive>:2395:1)
λ> x = Original 1
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> x = Original 1
λ> x
Original 1
λ> x = lreturn 1
λ> x
x :: (Thing t, Num a) => t a
λ> fmap (\x -> x+1) (Original 1)

<interactive>:2403:1-4: error:
    Ambiguous occurrence ‘fmap’
    It could refer to either ‘Prelude.fmap’,
                             imported from ‘Prelude’ at tensor-map.hs:1:1
                             (and originally defined in ‘GHC.Base’)
                          or ‘Main.fmap’, defined at tensor-map.hs:15:3
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> fmap (\x -> x+1) (Original 1)

<interactive>:2406:1-29: error:
    • Could not deduce (Functor State) arising from a use of ‘fmap’
      from the context: Num b
        bound by the inferred type of it :: Num b => State b
        at <interactive>:2406:1-29
    • In the expression: fmap (\ x -> x + 1) (Original 1)
      In an equation for ‘it’: it = fmap (\ x -> x + 1) (Original 1)
λ> lfmap (\x -> x+1) (Original 1)
New 2
λ> lfmap (\x -> x+1) (New 1)
New 1
λ> :t tmap

<interactive>:1:1-4: error:
    • Variable not in scope: tmap
    • Perhaps you meant one of these:
        ‘fmap’ (imported from Prelude), ‘map’ (imported from Prelude),
        ‘map’ (imported from Data.Map)
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> x = Original 1
λ> plusSome x

<interactive>:2474:1-10: error:
    • Non type-variable argument in the constraint: Num (State a)
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        it :: forall a. (Num a, Num (State a)) => State a
λ> tmap plusSome
tmap plusSome :: (Thing t, Num a) => t a -> t a
λ> tmap plusSome $ x
New 11
λ> x
Original 1
λ> tmap plusSome $ x
New 11
λ> tmap plusSome $ tmap plusSome $ x
New 11
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:28:3-4: error:
    Multiple declarations of ‘-:’
    Declared at: tensor-map.hs:8:3
                 tensor-map.hs:28:3
   |
28 | x -: f = f x
   |   ^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:28:3-4: error:
    Multiple declarations of ‘-:’
    Declared at: tensor-map.hs:8:3
                 tensor-map.hs:28:3
   |
28 | x -: f = f x
   |   ^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:11:30-32: error:
    • Couldn't match expected type ‘a -> a’ with actual type ‘State a’
    • The function ‘f’ is applied to one argument,
      but its type ‘State a’ has none
      In the first argument of ‘New’, namely ‘(f x)’
      In the expression: New (f x)
    • Relevant bindings include
        f :: State a (bound at tensor-map.hs:11:21)
        x :: a (bound at tensor-map.hs:11:18)
        (-:) :: f -> State a -> State a (bound at tensor-map.hs:11:3)
   |
11 |   (-:) (Original x) f = New (f x)
   |                              ^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:11:9-18: error:
    • Couldn't match expected type ‘a -> a’ with actual type ‘State t0’
    • In the pattern: Original x
      In an equation for ‘-:’: (-:) (Original x) f = New (f x)
      In the instance declaration for ‘Thing State’
    • Relevant bindings include
        (-:) :: (a -> a) -> State a -> State a
          (bound at tensor-map.hs:11:3)
   |
11 |   (-:) (Original x) f = New (f x)
   |         ^^^^^^^^^^

tensor-map.hs:11:30-32: error:
    • Couldn't match expected type ‘t0 -> a’ with actual type ‘State a’
    • The function ‘f’ is applied to one argument,
      but its type ‘State a’ has none
      In the first argument of ‘New’, namely ‘(f x)’
      In the expression: New (f x)
    • Relevant bindings include
        f :: State a (bound at tensor-map.hs:11:21)
        x :: t0 (bound at tensor-map.hs:11:18)
        (-:) :: (a -> a) -> State a -> State a
          (bound at tensor-map.hs:11:3)
   |
11 |   (-:) (Original x) f = New (f x)
   |                              ^^^

tensor-map.hs:12:9-13: error:
    • Couldn't match expected type ‘a -> a’ with actual type ‘State a’
    • In the pattern: New x
      In an equation for ‘-:’: (-:) (New x) f = New (x)
      In the instance declaration for ‘Thing State’
    • Relevant bindings include
        (-:) :: (a -> a) -> State a -> State a
          (bound at tensor-map.hs:11:3)
   |
12 |   (-:) (New x) f = New (x)
   |         ^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> treturn 1
treturn 1 :: (Thing t, Num a) => t a
λ> treturn 1 -: plusSome
treturn 1 -: plusSome :: (Thing t, Num a) => t a
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> treturn 1 -: plusSome
treturn 1 -: plusSome :: (Thing t, Num a) => t a
λ> treturn 1
treturn 1 :: (Thing t, Num a) => t a
λ> :t treturn
treturn :: Thing t => a -> t a
λ> treturn (1)
treturn (1) :: (Thing t, Num a) => t a
λ> treturn 1
treturn 1 :: (Thing t, Num a) => t a
λ> (treturn 1)
(treturn 1) :: (Thing t, Num a) => t a
λ> (treturn) 1
(treturn) 1 :: (Thing t, Num a) => t a
λ> -:

<interactive>:2575:1-2: error: parse error on input ‘-:’
λ> treturn
treturn :: Thing t => a -> t a
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> treturn 1
Original 1
λ> treturn 1 -: plusSome
New 11
λ> treturn 1 -: plusSome -: plusSome 
New 11
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> treturn 1 -: plusSome 1 -: plusSome 2
New 2
λ> plusSome 1
plusSome 1 :: Num a => a -> a
λ> y = plusSome 1
λ> y 2
3
λ> :t first

<interactive>:1:1-5: error: Variable not in scope: first
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> first 1 -: plusSome 1
New 2
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :t PolyNomial

<interactive>:1:1-10: error:
    Data constructor not in scope: PolyNomial
λ> :t Polynomial

<interactive>:1:1-10: error:
    Data constructor not in scope: Polynomial
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> zip [0,1..] [1, 2, 3]
[(0,1),(1,2),(2,3)]
λ> zip [0,1..] [1, 2, 3]
[(0,1),(1,2),(2,3)]
λ> zip [0,1..] [Pointer Gluon (1,1)]

<interactive>:2853:29: error:
    • Could not deduce (Num Index) arising from the literal ‘1’
      from the context: (Enum a, Num a)
        bound by the inferred type of
                   it :: (Enum a, Num a) => [(a, Pointer)]
        at <interactive>:2853:1-33
    • In the expression: 1
      In the second argument of ‘Pointer’, namely ‘(1, 1)’
      In the expression: Pointer Gluon (1, 1)
λ> zip [0,1..] [(Pointer Gluon (1,1))]

<interactive>:2854:30: error:
    • Could not deduce (Num Index) arising from the literal ‘1’
      from the context: (Enum a, Num a)
        bound by the inferred type of
                   it :: (Enum a, Num a) => [(a, Pointer)]
        at <interactive>:2854:1-35
    • In the expression: 1
      In the second argument of ‘Pointer’, namely ‘(1, 1)’
      In the expression: (Pointer Gluon (1, 1))
λ> Pointer Gluon (1,1)

<interactive>:2855:16: error:
    • No instance for (Num Index) arising from the literal ‘1’
    • In the expression: 1
      In the second argument of ‘Pointer’, namely ‘(1, 1)’
      In the expression: Pointer Gluon (1, 1)
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:18:15-57: error:
    • Couldn't match expected type ‘Map Int Pointer’
                  with actual type ‘Data.Set.Internal.Set k0 -> Map k0 a0’
    • In the second argument of ‘($)’, namely
        ‘fromSet $ zip [0, 1 .. ] [Pointer Gluon (1, 1)]’
      In the expression:
        Tensor $ fromSet $ zip [0, 1 .. ] [Pointer Gluon (1, 1)]
      In an equation for ‘t1’:
          t1 = Tensor $ fromSet $ zip [0, 1 .. ] [Pointer Gluon (1, 1)]
   |
18 | t1 = Tensor $ fromSet $ zip [0,1..] [Pointer Gluon (1,1)]
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tensor-map.hs:18:25-57: error:
    • Couldn't match expected type ‘k0 -> a0’
                  with actual type ‘[(Integer, Pointer)]’
    • Possible cause: ‘zip’ is applied to too many arguments
      In the second argument of ‘($)’, namely
        ‘zip [0, 1 .. ] [Pointer Gluon (1, 1)]’
      In the second argument of ‘($)’, namely
        ‘fromSet $ zip [0, 1 .. ] [Pointer Gluon (1, 1)]’
      In the expression:
        Tensor $ fromSet $ zip [0, 1 .. ] [Pointer Gluon (1, 1)]
   |
18 | t1 = Tensor $ fromSet $ zip [0,1..] [Pointer Gluon (1,1)]
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> Pointer Gluon (1,1)
Pointer Gluon (1,1)
λ> zip [0,1..] [Pointer Gluon (1,1)]
[(0,Pointer Gluon (1,1))]
λ> fromSet $ zip [0,1..] [Pointer Gluon (1,1)]

<interactive>:2862:11-43: error:
    • Couldn't match expected type ‘k -> a’
                  with actual type ‘[(Integer, Pointer)]’
    • Possible cause: ‘zip’ is applied to too many arguments
      In the second argument of ‘($)’, namely
        ‘zip [0, 1 .. ] [Pointer Gluon (1, 1)]’
      In the expression: fromSet $ zip [0, 1 .. ] [Pointer Gluon (1, 1)]
      In an equation for ‘it’:
          it = fromSet $ zip [0, 1 .. ] [Pointer Gluon (1, 1)]
    • Relevant bindings include
        it :: Data.Set.Internal.Set k -> Map k a
          (bound at <interactive>:2862:1)
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> fromSet $ zip [0,1..] [Pointer Gluon (1,1)]

<interactive>:2876:1-7: error:
    Ambiguous occurrence ‘fromSet’
    It could refer to either ‘Map.fromSet’,
                             imported from ‘Data.Map.Strict’ at tensor-map.hs:1:1-29
                             (and originally defined in ‘Data.Map.Strict.Internal’)
                          or ‘Data.Map.fromSet’,
                             imported from ‘Data.Map’
                             (and originally defined in ‘Data.Map.Internal’)
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> fromSet $ zip [0,1..] [Pointer Gluon (1,1)]

<interactive>:2879:1-7: error:
    Ambiguous occurrence ‘fromSet’
    It could refer to either ‘Data.Map.Strict.fromSet’,
                             imported from ‘Data.Map.Strict’ at tensor-map.hs:1:1-22
                             (and originally defined in ‘Data.Map.Strict.Internal’)
                          or ‘Data.Map.fromSet’,
                             imported from ‘Data.Map’
                             (and originally defined in ‘Data.Map.Internal’)
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:19:15-61: error:
    • Couldn't match expected type ‘Map Int Pointer’
                  with actual type ‘Data.Set.Internal.Set k0 -> Map k0 a0’
    • In the second argument of ‘($)’, namely
        ‘fromSet $ zip [0, 1 .. ] [Pointer Gluon (1, 1)]’
      In the expression:
        Tensor $ fromSet $ zip [0, 1 .. ] [Pointer Gluon (1, 1)]
      In an equation for ‘t1’:
          t1 = Tensor $ fromSet $ zip [0, 1 .. ] [Pointer Gluon (1, 1)]
   |
19 | t1 = Tensor $ Map.fromSet $ zip [0,1..] [Pointer Gluon (1,1)]
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tensor-map.hs:19:29-61: error:
    • Couldn't match expected type ‘k0 -> a0’
                  with actual type ‘[(Integer, Pointer)]’
    • Possible cause: ‘zip’ is applied to too many arguments
      In the second argument of ‘($)’, namely
        ‘zip [0, 1 .. ] [Pointer Gluon (1, 1)]’
      In the second argument of ‘($)’, namely
        ‘fromSet $ zip [0, 1 .. ] [Pointer Gluon (1, 1)]’
      In the expression:
        Tensor $ fromSet $ zip [0, 1 .. ] [Pointer Gluon (1, 1)]
   |
19 | t1 = Tensor $ Map.fromSet $ zip [0,1..] [Pointer Gluon (1,1)]
   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
λ> zip [0,1..] [Pointer Gluon (1,1)]

<interactive>:2882:14-20: error:
    Data constructor not in scope:
      Pointer :: t0 -> (Integer, Integer) -> b

<interactive>:2882:22-26: error:
    Data constructor not in scope: Gluon
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> zip [0,1..] [Pointer Gluon (1,1)]
[(0,Pointer Gluon (1,1))]
λ> x = zip [0,1..] [Pointer Gluon (1,1)]
λ> fromSet x

<interactive>:2886:1-7: error:
    Ambiguous occurrence ‘fromSet’
    It could refer to either ‘Map.fromSet’,
                             imported from ‘Data.Map.Strict’ at tensor-map.hs:1:1-29
                             (and originally defined in ‘Data.Map.Strict.Internal’)
                          or ‘Data.Map.fromSet’,
                             imported from ‘Data.Map’
                             (and originally defined in ‘Data.Map.Internal’)
λ> Map.fromSet x

<interactive>:2887:13: error:
    • Couldn't match expected type ‘k -> a’
                  with actual type ‘[(Integer, Pointer)]’
    • In the first argument of ‘Map.fromSet’, namely ‘x’
      In the expression: Map.fromSet x
      In an equation for ‘it’: it = Map.fromSet x
    • Relevant bindings include
        it :: Data.Set.Internal.Set k -> Map k a
          (bound at <interactive>:2887:1)
λ> Map.fromAscList x
fromList [(0,Pointer Gluon (1,1))]
λ> fromAscList x

<interactive>:2889:1-11: error:
    Ambiguous occurrence ‘fromAscList’
    It could refer to either ‘Map.fromAscList’,
                             imported from ‘Data.Map.Strict’ at tensor-map.hs:1:1-29
                             (and originally defined in ‘Data.Map.Strict.Internal’)
                          or ‘Data.Map.fromAscList’,
                             imported from ‘Data.Map’
                             (and originally defined in ‘Data.Map.Internal’)
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> t1
Tensor (fromList [(0,Pointer Gluon (1,1))])
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> t1
Tensor (fromList [(0,Pointer Gluon (-1,0)),(1,Pointer Gluon (1,0)),(2,Pointer Gluon (1,0))])
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> vs
TensorProduct (LaurentPolynomial.Cons 0 [1]) (Tensors (fromList [(0,Tensor (fromList [(0,Pointer Gluon (-1,0)),(1,Pointer Gluon (1,0)),(2,Pointer Gluon (1,0))])),(1,Tensor (fromList [(0,Pointer Gluon (-2,0)),(1,Pointer Gluon (1,0)),(2,Pointer Gluon (1,0))]))]))
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :l pop
target ‘pop’ is not a module name or a source file
λ> :t pop

<interactive>:1:1-3: error: Variable not in scope: pop
λ> vs
TensorProduct (LaurentPolynomial.Cons 0 [1]) (Tensors (fromList [(0,Tensor (fromList [(0,Pointer (-1,0) Gluon),(1,Pointer (1,1) Down),(2,Pointer (1,0) Up)])),(1,Tensor (fromList [(0,Pointer (0,2) Down),(1,Pointer (0,1) Up),(2,Pointer (-2,0) Gluon)]))]))
λ> x = Map.fromAscList $ zip [0,1..] [t1, t2]
λ> x
fromList [(0,Tensor (fromList [(0,Pointer (-1,0) Gluon),(1,Pointer (1,1) Down),(2,Pointer (1,0) Up)])),(1,Tensor (fromList [(0,Pointer (0,2) Down),(1,Pointer (0,1) Up),(2,Pointer (-2,0) Gluon)]))]
λ> x !! 0

<interactive>:3026:1: error:
    • Couldn't match expected type ‘[a]’
                  with actual type ‘Map Integer Tensor’
    • In the first argument of ‘(!!)’, namely ‘x’
      In the expression: x !! 0
      In an equation for ‘it’: it = x !! 0
    • Relevant bindings include it :: a (bound at <interactive>:3026:1)
λ> group

<interactive>:3027:1-5: error: Variable not in scope: group
λ> :t group

<interactive>:1:1-5: error: Variable not in scope: group
λ> [

<interactive>:3029:2: error:
    parse error (possibly incorrect indentation or mismatched brackets)
λ> x = [3,1,]

<interactive>:3106:10: error: parse error on input ‘]’
λ> x = [3,1,3]
λ> :t group

<interactive>:1:1-5: error: Variable not in scope: group
λ> import Data.List
λ> :t group
group :: Eq a => [a] -> [[a]]
λ> group x
[[3],[1],[3]]
λ> sort x
[1,3,3]
λ> group $ sort x
[[1],[3,3]]
λ> y = group $ sort x
λ> [i | head i <- y, length i == 1]

<interactive>:3115:6-11: error:
    Parse error in pattern: head
    Possibly caused by a missing 'do'?
λ> [i | head i <- y,]

<interactive>:3116:6-11: error:
    Parse error in pattern: head
    Possibly caused by a missing 'do'?
λ> [ head i | i <- y, length i == 1 ]
[1]
λ> [ head i | i <- (group $ sort x), length i == 1 ]
[1]
λ> f x = [ head i | i <- (group $ sort x), length i == 1 ]
λ> f [1,2,2]
[1]
λ> f [1,2,3]
[1,2,3]
λ> group $ sort [1,2,3]
[[1],[2],[3]]
λ> tails [1,2,3]
[[1,2,3],[2,3],[3],[]]
λ> tails $ group $ sort x
[[[1],[3,3]],[[3,3]],[]]
λ> x 
[3,1,3]
λ> f1 x = tails $ group sort x

<interactive>:3126:16-27: error:
    • Couldn't match expected type ‘t -> [a]’ with actual type ‘[[()]]’
    • The function ‘group’ is applied to two arguments,
      but its type ‘[()] -> [[()]]’ has only one
      In the second argument of ‘($)’, namely ‘group sort x’
      In the expression: tails $ group sort x
    • Relevant bindings include
        x :: t (bound at <interactive>:3126:4)
        f1 :: t -> [[a]] (bound at <interactive>:3126:1)

<interactive>:3126:22-25: error:
    • Couldn't match expected type ‘[()]’
                  with actual type ‘[()] -> [()]’
    • Probable cause: ‘sort’ is applied to too few arguments
      In the first argument of ‘group’, namely ‘sort’
      In the second argument of ‘($)’, namely ‘group sort x’
      In the expression: tails $ group sort x
λ> f1 x = tails $ group $ sort x
λ> f1 x
[[[1],[3,3]],[[3,3]],[]]
λ> f1 x
[[[1],[3,3]],[[3,3]],[]]
λ> f x = [ head i | i <- (group $ sort x), length i == 1 ]
λ> f x
[1]
λ> group $ sort x
[[1],[3,3]]
λ> y = group $ sort x
λ> z = if length y == 2 then 

<interactive>:3134:27: error:
    parse error (possibly incorrect indentation or mismatched brackets)
λ> 
λ> f1 x = group $ sort x
λ> f1 x
[[1],[3,3]]
λ> f2 x = [ i | i <- x, length i == 1]
λ> f3 x = if 1 == length f1 x then Just f2 x else Nothing

<interactive>:3138:16-26: error:
    • Couldn't match expected type ‘t -> Integer’
                  with actual type ‘Int’
    • The function ‘length’ is applied to two arguments,
      but its type ‘([()] -> [[()]]) -> Int’ has only one
      In the second argument of ‘(==)’, namely ‘length f1 x’
      In the expression: 1 == length f1 x
    • Relevant bindings include
        x :: t (bound at <interactive>:3138:4)
        f3 :: t -> Maybe a (bound at <interactive>:3138:1)

<interactive>:3138:33-41: error:
    • Couldn't match expected type ‘t -> Maybe a’
                  with actual type ‘Maybe ([[a0]] -> [[a0]])’
    • The function ‘Just’ is applied to two arguments,
      but its type ‘([[a0]] -> [[a0]]) -> Maybe ([[a0]] -> [[a0]])’
      has only one
      In the expression: Just f2 x
      In the expression: if 1 == length f1 x then Just f2 x else Nothing
    • Relevant bindings include
        x :: t (bound at <interactive>:3138:4)
        f3 :: t -> Maybe a (bound at <interactive>:3138:1)
λ> f3 x = if 1 == length f1 x then Just (f2 x) else Nothing

<interactive>:3139:16-26: error:
    • Couldn't match expected type ‘[t a] -> Integer’
                  with actual type ‘Int’
    • The function ‘length’ is applied to two arguments,
      but its type ‘([()] -> [[()]]) -> Int’ has only one
      In the second argument of ‘(==)’, namely ‘length f1 x’
      In the expression: 1 == length f1 x
    • Relevant bindings include
        x :: [t a] (bound at <interactive>:3139:4)
        f3 :: [t a] -> Maybe [t a] (bound at <interactive>:3139:1)
λ> f3 x = if 1 == length (f1 x) then Just (f2 x) else Nothing
λ> f3 x

<interactive>:3141:1-4: error:
    • No instance for (Num [()]) arising from a use of ‘it’
    • In the first argument of ‘print’, namely ‘it’
      In a stmt of an interactive GHCi command: print it
λ> x
[3,1,3]
λ> f1
f1 :: Ord a => [a] -> [[a]]
λ> f2
f2 :: Foldable t => [t a] -> [t a]
λ> f x
[1]
λ> f1 x
[[1],[3,3]]
λ> f2 x

<interactive>:3149:1-4: error:
    • No instance for (Num [()]) arising from a use of ‘it’
    • In the first argument of ‘print’, namely ‘it’
      In a stmt of an interactive GHCi command: print it
λ> f2 x = [ i | i <- x, length i == 1]
λ> f2 x

<interactive>:3151:1-4: error:
    • No instance for (Num [()]) arising from a use of ‘it’
    • In the first argument of ‘print’, namely ‘it’
      In a stmt of an interactive GHCi command: print it
λ> f2 f1 x

<interactive>:3152:1-7: error:
    • Couldn't match expected type ‘[Integer] -> t’
                  with actual type ‘[[a0]]’
    • The function ‘f2’ is applied to two arguments,
      but its type ‘[[a0]] -> [[a0]]’ has only one
      In the expression: f2 f1 x
      In an equation for ‘it’: it = f2 f1 x
    • Relevant bindings include it :: t (bound at <interactive>:3152:1)

<interactive>:3152:4-5: error:
    • Couldn't match expected type ‘[[a0]]’
                  with actual type ‘[()] -> [[()]]’
    • Probable cause: ‘f1’ is applied to too few arguments
      In the first argument of ‘f2’, namely ‘f1’
      In the expression: f2 f1 x
      In an equation for ‘it’: it = f2 f1 x
λ> f2 $ f1 x
[[1]]
λ> f1 x
[[1],[3,3]]
λ> f2 x = [ head i | i <- x, length i == 1]
λ> f2 $ f1 x
[1]
λ> head $ f2 $ f1 x
1
λ> head f2 $ f1 x

<interactive>:3158:6-7: error:
    • Couldn't match expected type ‘[[[Integer]] -> t]’
                  with actual type ‘[[a0]] -> [a0]’
    • Probable cause: ‘f2’ is applied to too few arguments
      In the first argument of ‘head’, namely ‘f2’
      In the expression: head f2
      In the expression: head f2 $ f1 x
    • Relevant bindings include it :: t (bound at <interactive>:3158:1)
λ> f1 x
[[1],[3,3]]
λ> f2 $ f1 x
[1]
λ> x
[3,1,3]
λ> x [1,2,3]

<interactive>:3168:1-9: error:
    • Couldn't match expected type ‘[Integer] -> t’
                  with actual type ‘[Integer]’
    • The function ‘x’ is applied to one argument,
      but its type ‘[Integer]’ has none
      In the expression: x [1, 2, 3]
      In an equation for ‘it’: it = x [1, 2, 3]
    • Relevant bindings include it :: t (bound at <interactive>:3168:1)
λ> x = [1,2,3]
λ> f1 x
[[1],[2],[3]]
λ> f2 $ f1 x
[1,2,3]
λ> f1 x
[[1],[2],[3]]
λ> length x
3
λ> y = if 2 == length x then 2 else 9
λ> 
λ> y
9
λ> y = if 2 == length x then f2 x else []

<interactive>:3176:1-38: error:
    • Non type-variable argument in the constraint: Num [a]
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        y :: forall a. Num [a] => [a]
λ> f2 x

<interactive>:3177:1-4: error:
    • Non type-variable argument in the constraint: Num [a]
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        it :: forall a. Num [a] => [a]
λ> f2 x = [ head i | i <- x, length i == 1 ]
λ> f2 x

<interactive>:3180:1-4: error:
    • Non type-variable argument in the constraint: Num [a]
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        it :: forall a. Num [a] => [a]
λ> x = [3,2,3]
λ> f1 x
[[2],[3,3]]
λ> f2 $ f1 x
[2]
λ> y x = 
 where grouped = group $ sort x
Some flags have not been recognized: prompt2, 
*Main Data.Map Data.List| *Main Data.Map Data.List| *Main Data.Map Data.List| 
<interactive>:3226:2-6: error: parse error on input ‘where’
Some flags have not been recognized: prompt2, λ| 
λ> 
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:51:15-19: error:
    Variable not in scope: group :: t1 -> t
   |
51 |     grouped = group $ sort x
   |               ^^^^^

tensor-map.hs:51:23-26: error:
    • Variable not in scope: sort :: p -> t1
    • Perhaps you meant ‘sqrt’ (imported from Prelude)
   |
51 |     grouped = group $ sort x
   |                       ^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> x = [1,2,2]
λ> y x
[1]
λ> x = [1,2,3]
λ> y x
[]
λ> :t single

<interactive>:1:1-6: error: Variable not in scope: single
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:38:12-13: error:
    • Couldn't match expected type ‘[a2] -> [a2]’
                  with actual type ‘[a0]’
    • In the second argument of ‘(/=)’, namely ‘[]’
      In the expression: idx /= []
      In a stmt of a pattern guard for
                     an equation for ‘nonBubblePointer’:
        idx /= []
   |
38 |   | idx /= [] = Just idx
   |            ^^

tensor-map.hs:38:17-24: error:
    • Couldn't match type ‘[a1] -> [a1]’ with ‘Pointer’
      Expected type: Maybe Pointer
        Actual type: Maybe ([a1] -> [a1])
    • In the expression: Just idx
      In an equation for ‘nonBubblePointer’:
          nonBubblePointer (Tensor pointers)
            | idx /= [] = Just idx
            | otherwise = Nothing
            where
                idx x
                  = if 2 == length grouped then singleOf grouped else []
                  where
                      singleOf x = ...
                      grouped = group $ sort x
   |
38 |   | idx /= [] = Just idx
   |                 ^^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:38:26-42: error:
    • Couldn't match type ‘[Int]’ with ‘Pointer’
      Expected type: Maybe Pointer
        Actual type: Maybe [Int]
    • In the expression: Just nonBubbleIDX
      In an equation for ‘nonBubblePointer’:
          nonBubblePointer (Tensor pointers)
            | nonBubbleIDX /= [] = Just nonBubbleIDX
            | otherwise = Nothing
            where
                vsIDXs = [vsIDX | (vsIDX, _) <- toAscList pointers]
                uniqueIDX x
                  = if 2 == length grouped then uniqueOf grouped else []
                  where
                      uniqueOf x = ...
                      grouped = group $ sort x
                nonBubbleIDX = uniqueIDX vsIDXs
   |
38 |   | nonBubbleIDX /= [] = Just nonBubbleIDX
   |                          ^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> nonBubblePointer t1
Nothing
λ> nonBubblePointer t2
Nothing
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> nonBubblePointer t1
Nothing
λ> toAscList [
  Pointer (0,2) Down,
  Pointer (0,1) Up,
  Pointer (-2,0) Gluon
  ]
Some flags have not been recognized: prompt2, 
*Main Data.Map Data.List| *Main Data.Map Data.List| *Main Data.Map Data.List| *Main Data.Map Data.List| *Main Data.Map Data.List| *Main Data.Map Data.List| 
<interactive>:(3421,11)-(3425,3): error:
    • Couldn't match expected type ‘Map k a’
                  with actual type ‘[Pointer]’
    • In the first argument of ‘toAscList’, namely
        ‘[Pointer (0, 2) Down, Pointer (0, 1) Up, Pointer (- 2, 0) Gluon]’
      In the expression:
        toAscList
          [Pointer (0, 2) Down, Pointer (0, 1) Up, Pointerλ> 
λ> t1
Tensor (fromList [(0,Pointer (-1,0) Gluon),(1,Pointer (1,1) Down),(2,Pointer (1,0) Up)])
λ> f (Tensor pointers) = toAscList pointers
λ> f t1
[(0,Pointer (-1,0) Gluon),(1,Pointer (1,1) Down),(2,Pointer (1,0) Up)]
λ> f (Tensor pointers) = toAscList pointers
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> nonBubblePointer t1
Nothing
λ> f (Tensor pointers) = [ vsIDX | (_, Pointer (vsIDX) _) <- toAscList pointers]
λ> f t1
[(-1,0),(1,1),(1,0)]
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> nonBubblePointer t1
Just [-1]
λ> nonBubblePointer t2
Just [-2]
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:32:1-2: error:
    Multiple declarations of ‘t2’
    Declared at: tensor-map.hs:26:1
                 tensor-map.hs:32:1
   |
32 | t2 = Tensor $ Map.fromAscList $ zip [0,1..] [
   | ^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> nonBubblePointer t3
Nothing
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:44:26-42: error:
    • Couldn't match type ‘[Int]’ with ‘Pointer’
      Expected type: Maybe Pointer
        Actual type: Maybe [Int]
    • In the expression: Just nonBubbleIDX
      In an equation for ‘nonBubblePointer’:
          nonBubblePointer (Tensor pointers)
            | nonBubbleIDX /= [] = Just nonBubbleIDX
            | otherwise = Nothing
            where
                vsIDXs = [vsIDX | (_, Pointer (vsIDX, _) _) <- toAscList pointers]
                uniqueIDX x
                  = if 2 == length grouped then uniqueOf grouped else []
                  where
                      uniqueOf x = ...
                      grouped = group $ sort x
                nonBubbleIDX = uniqueIDX vsIDXs
   |
44 |   | nonBubbleIDX /= [] = Just nonBubbleIDX
   |                          ^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :t nonBubblePointer
nonBubblePointer :: Tensor -> Maybe [Int]
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> nonBubblePointer t1
Just (-1)
λ> nonBubblePointer t3
Nothing
λ> f1 (Tensor pointers) = toAscList pointers
λ> t1 t1

<interactive>:3543:1-5: error:
    • Couldn't match expected type ‘Tensor -> t’
                  with actual type ‘Tensor’
    • The function ‘t1’ is applied to one argument,
      but its type ‘Tensor’ has none
      In the expression: t1 t1
      In an equation for ‘it’: it = t1 t1
    • Relevant bindings include it :: t (bound at <interactive>:3543:1)
λ> f1 t1
[(0,Pointer (-1,0) Gluon),(1,Pointer (1,1) Down),(2,Pointer (1,0) Up)]
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :l tensor.hs
:l te[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> nonB

<interactive>:3599:1-4: error: Variable not in scope: nonB
λ> 
λ> :l tensor.hs
[1 of 1] Compiling Main             ( tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> nonBubblePointer t1

<interactive>:3603:1-16: error:
    Variable not in scope: nonBubblePointer :: IndexableObject -> t
λ> t1
Tensor [Pointer Gluon (-1,0),Pointer Up (1,2),Pointer Down (1,1)]
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> nonBubblePointer t1
[-1]
λ> nonBubblePointer t2
[-2]
λ> nonBubblePointer t3
[]
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :t nonBubblePointer

Some flags have not been recognized: prompt2, 
*Main Data.Map Data.List| *Main Data.Map Data.List| *Main Data.Map Data.List| nonBubblePointer :: Tensor -> [Int]
Some flags have not been recognized: prompt2, λ| 
λ> f1 (Tensor pointers) = toAscList pointers
λ> f1 t1
[(0,Pointer (-1,0) Gluon),(1,Pointer (1,1) Down),(2,Pointer (1,0) Up)]
λ> groupBy (head x == head y) $ f1 t1

<interactive>:3640:10-25: error:
    • Couldn't match expected type ‘(Int, Pointer)
                                    -> (Int, Pointer) -> Bool’
                  with actual type ‘Bool’
    • Possible cause: ‘(==)’ is applied to too many arguments
      In the first argument of ‘groupBy’, namely ‘(head x == head y)’
      In the expression: groupBy (head x == head y)
      In the expression: groupBy (head x == head y) $ f1 t1

<interactive>:3640:15: error: Variable not in scope: x :: [()]

<interactive>:3640:25: error: Variable not in scope: y :: [()]
λ> groupBy (\x -> y -> head x == head y) $ f1 t1

<interactive>:3641:10-36: error:
    Pattern syntax in expression context: \ x -> y -> head x == head y
λ> groupBy (\x -> y -> head x == head y) $ f1 t1

<interactive>:3642:10-36: error:
    Pattern syntax in expression context: \ x -> y -> head x == head y
λ> (\x -> y -> head x == head y)

<interactive>:3643:2-28: error:
    Pattern syntax in expression context: \ x -> y -> head x == head y
λ> :t (\x -> y -> head x == head y)

<interactive>:1:2-28: error:
    Pattern syntax in expression context: \ x -> y -> head x == head y
λ> (\x -> x*2)
(\x -> x*2) :: Num a => a -> a
λ> (\x -> y -> x*2)

<interactive>:3647:2-15: error:
    Pattern syntax in expression context: \ x -> y -> x * 2
λ> (\x y -> x*2)
(\x y -> x*2) :: Num a => a -> p -> a
λ> groupBy (\x y -> head x == head y) $ f1 t1

<interactive>:3650:38-42: error:
    • Couldn't match type ‘(Int, Pointer)’ with ‘[a]’
      Expected type: [[a]]
        Actual type: [(Int, Pointer)]
    • In the second argument of ‘($)’, namely ‘f1 t1’
      In the expression: groupBy (\ x y -> head x == head y) $ f1 t1
      In an equation for ‘it’:
          it = groupBy (\ x y -> head x == head y) $ f1 t1
    • Relevant bindings include
        it :: [[[a]]] (bound at <interactive>:3650:1)
λ> f1 t1
[(0,Pointer (-1,0) Gluon),(1,Pointer (1,1) Down),(2,Pointer (1,0) Up)]
λ> groupBy (\x y -> fst x == fst y) $ f1 t1
[[(0,Pointer (-1,0) Gluon)],[(1,Pointer (1,1) Down)],[(2,Pointer (1,0) Up)]]
λ> groupBy (\x y -> fst x == fst y) $ f1 t1
[[(0,Pointer (-1,0) Gluon)],[(1,Pointer (1,1) Down)],[(2,Pointer (1,0) Up)]]
λ> getPoinerVals (Pointer vals, _) = vals

<interactive>:3654:16-27: error:
    • The constructor ‘Pointer’ should have 2 arguments, but has been given 1
    • In the pattern: Pointer vals
      In the pattern: (Pointer vals, _)
      In an equation for ‘getPoinerVals’:
          getPoinerVals (Pointer vals, _) = vals
λ> getPoinerVals (Pointer vals _) = vals
λ> getPointerVals 

<interactive>:3656:1-14: error:
    • Variable not in scope: getPointerVals
    • Perhaps you meant ‘getPoinerVals’ (line 3655)
λ> groupBy (\x y -> fst $ getPointerVals $ snd x == fst $ getPointerVals $ snd y) $ f1 t1

<interactive>:3659:24-37: error:
    • Variable not in scope: getPointerVals :: t0 -> (Bool, b0)
    • Perhaps you meant ‘getPoinerVals’ (line 3655)

<interactive>:3659:41-77: error:
    • Couldn't match expected type ‘t1 -> t0’ with actual type ‘Bool’
    • The first argument of ($) takes one argument,
      but its type ‘Bool’ has none
      In the second argument of ‘($)’, namely
        ‘snd x == fst $ getPointerVals $ snd y’
      In the second argument of ‘($)’, namely
        ‘getPointerVals $ snd x == fst $ getPointerVals $ snd y’

<interactive>:3659:56-69: error:
    • Variable not in scope: getPointerVals :: ((a, b) -> a) -> t1
    • Perhaps you meant ‘getPoinerVals’ (line 3655)

<interactive>:3659:82-86: error:
    • Couldn't match type ‘Pointer’ with ‘(a, b) -> a’
      Expected type: [(Int, (a, b) -> a)]
        Actual type: [(Int, Pointer)]
    • In the second argument of ‘($)’, namely ‘f1 t1’
      In the expression:
        groupBy
          (\ x y
             -> fst $ getPointerVals $ snd x == fst $ getPointerVals $ snd y)
          $ f1 t1
      In an equation for ‘it’:
          it
            = groupBy
                (\ x y
                   -> fst $ getPointerVals $ snd x == fst $ getPointerVals $ snd y)
                $ f1 t1
    • Relevant bindings include
        it :: [[(Int, (a, b) -> a)]] (bound at <interactive>:3659:1)
λ> pointsSame0 (Pointer vals0 _) (Pointer vals1 _) = fst val0 == fst vals 1

<interactive>:3660:55-58: error:
    • Variable not in scope: val0 :: ((), b0)
    • Perhaps you meant ‘vals0’ (line 3660)

<interactive>:3660:67-70: error:
    • Variable not in scope: vals :: (Integer -> (), b1)
    • Perhaps you meant one of these:
        ‘vals0’ (line 3660), ‘vals1’ (line 3660)
λ> pointsSame0 (Pointer vals0 _) (Pointer vals1 _) = fst val0 == fst vals1

<interactive>:3661:55-58: error:
    • Variable not in scope: val0 :: (Int, b0)
    • Perhaps you meant ‘vals0’ (line 3661)
λ> pointsSame0 (Pointer vals0 _) (Pointer vals1 _) = fst vals0 == fst vals1
λ> pointsSame0 (Pointer (1,1) Up) (Pointer (0,1) Up)
False
λ> pointsSame0 (Pointer (1,1) Up) (Pointer (1,1) Up)
True
λ> groupBy (\x y -> head x == head y) $ f1 t1

Some flags have not been recognized: prompt2, 
*Main Data.Map Data.List| *Main Data.Map Data.List| *Main Data.Map Data.List| 
<interactive>:3667:38-42: error:
    • Couldn't match type ‘(Int, Pointer)’ with ‘[a]’
      Expected type: [[a]]
        Actual type: [(Int, Pointer)]
    • In the second argument of ‘($)’, namely ‘f1 t1’
      In the expression: groupBy (\ x y -> head x == head y) $ f1 t1
      In an equation for ‘it’:
          it = groupBy (\ x y -> head x == head y) $ f1 t1
    • Relevant bindings include
        it :: [[[a]]] (bound at <interactive>:3667:1)
Some flags have not been recognized: prompt2, λ| 
λ> 
λ> pointsSame0 (Pointer (1,1) Up) (Pointer (1,1) Up)
True
λ> f1 t1
[(0,Pointer (-1,0) Gluon),(1,Pointer (1,1) Down),(2,Pointer (1,0) Up)]
λ> groupBy pointsSame0 $ f1 t1

<interactive>:3673:23-27: error:
    • Couldn't match type ‘(Int, Pointer)’ with ‘Pointer’
      Expected type: [Pointer]
        Actual type: [(Int, Pointer)]
    • In the second argument of ‘($)’, namely ‘f1 t1’
      In the expression: groupBy pointsSame0 $ f1 t1
      In an equation for ‘it’: it = groupBy pointsSame0 $ f1 t1
λ> groupBy pointsSame0 $ snd $ f1 t1

<interactive>:3674:29-33: error:
    • Couldn't match expected type ‘(a0, [Pointer])’
                  with actual type ‘[(Int, Pointer)]’
    • In the second argument of ‘($)’, namely ‘f1 t1’
      In the second argument of ‘($)’, namely ‘snd $ f1 t1’
      In the expression: groupBy pointsSame0 $ snd $ f1 t1
λ> groupBy pointsSame0 $ map snd $ f1 t1

<interactive>:3675:23-25: error:
    Ambiguous occurrence ‘map’
    It could refer to either ‘Data.List.map’,
                             imported from ‘Data.List’ (and originally defined in ‘GHC.Base’)
                          or ‘Map.map’,
                             imported from ‘Data.Map.Strict’ at tensor-map.hs:2:1-29
                             (and originally defined in ‘Data.Map.Strict.Internal’)
                          or ‘Data.Map.map’,
                             imported from ‘Data.Map’
                             (and originally defined in ‘Data.Map.Internal’)
λ> f1 t1
[(0,Pointer (-1,0) Gluon),(1,Pointer (1,1) Down),(2,Pointer (1,0) Up)]
λ> :t pointsSame0n

<interactive>:1:1-12: error:
    • Variable not in scope: pointsSame0n
    • Perhaps you meant ‘pointsSame0’ (line 3662)
λ> :t pointsSame0
pointsSame0 :: Pointer -> Pointer -> Bool
λ> pointsSame0 (_,(Pointer vals0 _)) (_,(Pointer vals1 _)) = fst vals0 == fst vals1
λ> groupBy pointsSame0 $ map snd $ f1 t1

<interactive>:3681:23-25: error:
    Ambiguous occurrence ‘map’
    It could refer to either ‘Data.List.map’,
                             imported from ‘Data.List’ (and originally defined in ‘GHC.Base’)
                          or ‘Map.map’,
                             imported from ‘Data.Map.Strict’ at tensor-map.hs:2:1-29
                             (and originally defined in ‘Data.Map.Strict.Internal’)
                          or ‘Data.Map.map’,
                             imported from ‘Data.Map’
                             (and originally defined in ‘Data.Map.Internal’)
λ> groupBy pointsSame0 $ f1 t1
[[(0,Pointer (-1,0) Gluon)],[(1,Pointer (1,1) Down),(2,Pointer (1,0) Up)]]
λ> pointsSame0 (_,(Pointer vals0 _)) (_,(Pointer vals1 _)) = fst vals0 == fst vals1
λ> groupedPointers = groupBy pointsSame0 $ f1 t1
λ> groupedPointers
[[(0,Pointer (-1,0) Gluon)],[(1,Pointer (1,1) Down),(2,Pointer (1,0) Up)]]
λ> uniqueOf xg = [ head i | i <- xg, length i == 1]
λ> uniqueOf groupedPointers
[(0,Pointer (-1,0) Gluon)]
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> nonBubblePointer t1
[(0,Pointer (-1,0) Gluon)]
λ> nonBubblePointer t2
[(2,Pointer (-2,0) Gluon)]
λ> nonBubblePointer t3
[]
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> nonBubblePointer t3
[]
λ> nonBubblePointer t1
[Pointer (-1,0) Gluon]
λ> nonBubblePointer t3
[]
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:56:5-21: error:
    • No instance for (Eq Pointer) arising from a use of ‘/=’
    • In the expression: [] /= uniqueElems
      In a stmt of a pattern guard for
                     an equation for ‘nonBubblePointer’:
        [] /= uniqueElems
      In an equation for ‘nonBubblePointer’:
          nonBubblePointer (Tensor pointers)
            | [] /= uniqueElems = Just $ head uniqueElems
            | otherwise = Nothing
            where
                pointersList = [pointer | (_, pointer) <- toAscList pointers]
                pointsSame0 (Pointer vals0 _) (Pointer vals1 _)
                  = fst vals0 == fst vals1
                groupedPointersMap = groupBy pointsSame0 pointersList
                uniqueOf xg = [head i | i <- xg, length i == 1]
                ....
   |
56 |   | [] /= uniqueElems = Just $ head uniqueElems
   |     ^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> nonBubblePointer t1
[Pointer (-1,0) Gluon]
λ> nonBubblePointer t2
[Pointer (-2,0) Gluon]
λ> nonBubblePointer t3
[]
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:56:5-21: error:
    • No instance for (Eq Pointer) arising from a use of ‘/=’
    • In the expression: [] /= uniqueElems
      In a stmt of a pattern guard for
                     an equation for ‘nonBubblePointer’:
        [] /= uniqueElems
      In an equation for ‘nonBubblePointer’:
          nonBubblePointer (Tensor pointers)
            | [] /= uniqueElems = Just $ head uniqueElems
            | otherwise = Nothing
            where
                pointersList = [pointer | (_, pointer) <- toAscList pointers]
                pointsSame0 (Pointer vals0 _) (Pointer vals1 _)
                  = fst vals0 == fst vals1
                groupedPointersMap = groupBy pointsSame0 pointersList
                uniqueOf xg = [head i | i <- xg, length i == 1]
                ....
   |
56 |   | [] /= uniqueElems = Just $ head uniqueElems
   |     ^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:56:5-21: error:
    • No instance for (Eq Pointer) arising from a use of ‘/=’
    • In the expression: [] /= uniqueElems
      In a stmt of a pattern guard for
                     an equation for ‘nonBubblePointer’:
        [] /= uniqueElems
      In an equation for ‘nonBubblePointer’:
          nonBubblePointer (Tensor pointers)
            | [] /= uniqueElems = Just (head uniqueElems)
            | otherwise = Nothing
            where
                pointersList = [pointer | (_, pointer) <- toAscList pointers]
                pointsSame0 (Pointer vals0 _) (Pointer vals1 _)
                  = fst vals0 == fst vals1
                groupedPointersMap = groupBy pointsSame0 pointersList
                uniqueOf xg = [head i | i <- xg, length i == 1]
                ....
   |
56 |   | [] /= uniqueElems = Just (head uniqueElems)
   |     ^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:56:5-21: error:
    • No instance for (Eq Pointer) arising from a use of ‘==’
    • In the expression: [] == uniqueElems
      In a stmt of a pattern guard for
                     an equation for ‘nonBubblePointer’:
        [] == uniqueElems
      In an equation for ‘nonBubblePointer’:
          nonBubblePointer (Tensor pointers)
            | [] == uniqueElems = Nothing
            | otherwise = Just (head uniqueElems)
            where
                pointersList = [pointer | (_, pointer) <- toAscList pointers]
                pointsSame0 (Pointer vals0 _) (Pointer vals1 _)
                  = fst vals0 == fst vals1
                groupedPointersMap = groupBy pointsSame0 pointersList
                uniqueOf xg = [head i | i <- xg, length i == 1]
                ....
   |
56 |   | [] == uniqueElems = Nothing
   |     ^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:56:5-21: error:
    • No instance for (Eq Pointer) arising from a use of ‘==’
    • In the expression: [] == uniqueElems
      In a stmt of a pattern guard for
                     an equation for ‘nonBubblePointer’:
        [] == uniqueElems
      In an equation for ‘nonBubblePointer’:
          nonBubblePointer (Tensor pointers)
            | [] == uniqueElems = Nothing
            | otherwise = Just (uniqueElems)
            where
                pointersList = [pointer | (_, pointer) <- toAscList pointers]
                pointsSame0 (Pointer vals0 _) (Pointer vals1 _)
                  = fst vals0 == fst vals1
                groupedPointersMap = groupBy pointsSame0 pointersList
                uniqueOf xg = [head i | i <- xg, length i == 1]
                ....
   |
56 |   | [] == uniqueElems = Nothing
   |     ^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :t uniqueElems

<interactive>:1:1-11: error: Variable not in scope: uniqueElems
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> nonBubblePointer t2

Some flags have not been recognized: prompt2, 
*Main Data.Map Data.List| *Main Data.Map Data.List| *Main Data.Map Data.List| λ> :t uniqueElems

<interactive>:1:1-11: error: Variable not in scope: uniqueElems
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> nonBubblePointer t3
[]
λ> nonBubblePointer t2

Some flags have not been recognized: prompt2, 
*Main Data.Map Data.List| *Main Data.Map Data.List| *Main Data.Map Data.List| [Pointer (-2,0) Gluon]
Some flags have not been recognized: prompt2, λ| 
λ> nonBubblePointer t1
[Pointer (-1,0) Gluon]
λ> nonBubblePointer t2
[Pointer (-2,0) Gluon]
λ> nonBubblePointer t3
[]
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> nonBubblePointer t1
Pointer (-1,0) Gluon
λ> nonBubblePointer t2
Pointer (-2,0) Gluon
λ> nonBubblePointer t3
*** Exception: Prelude.head: empty list
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> nonBubblePointer t1
Just (Pointer (-1,0) Gluon)
λ> nonBubblePointer t3
Just *** Exception: Prelude.head: empty list
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> nonBubblePointer t1
Just (Pointer (-1,0) Gluon)
λ> nonBubblePointer t2
Just (Pointer (-2,0) Gluon)
λ> nonBubblePointer t3
Nothing
λ> t1
Tensor (fromList [(0,Pointer (-1,0) Gluon),(1,Pointer (1,1) Down),(2,Pointer (1,0) Up)])
λ> f (Tensor pointers) = Map.fromAscList pointers

<interactive>:3983:39-46: error:
    • Couldn't match expected type ‘[(k, a)]’
                  with actual type ‘Map Int Pointer’
    • In the first argument of ‘Map.fromAscList’, namely ‘pointers’
      In the expression: Map.fromAscList pointers
      In an equation for ‘f’:
          f (Tensor pointers) = Map.fromAscList pointers
    • Relevant bindings include
        f :: Tensor -> Map k a (bound at <interactive>:3983:1)
λ> f (Tensor pointers) = Map.toAscList pointers
λ> f t1
[(0,Pointer (-1,0) Gluon),(1,Pointer (1,1) Down),(2,Pointer (1,0) Up)]
λ> f (Tensor pointers) = [pointer | (_, pointer) <- Map.toAscList pointers]
λ> f t1
[Pointer (-1,0) Gluon,Pointer (1,1) Down,Pointer (1,0) Up]
λ> :t filter

<interactive>:1:1-6: error:
    Ambiguous occurrence ‘filter’
    It could refer to either ‘Data.List.filter’,
                             imported from ‘Data.List’ (and originally defined in ‘GHC.List’)
                          or ‘Data.Map.filter’,
                             imported from ‘Data.Map’
                             (and originally defined in ‘Data.Map.Internal’)
λ> :t Data.List.filter
Data.List.filter :: (a -> Bool) -> [a] -> [a]
λ> notGluon (Pointer (i,j) Gluon) = True
λ> notGluon (Pointer (0,0) Up)
*** Exception: <interactive>:3992:1-37: Non-exhaustive patterns in function notGluon

λ> notGluon (Pointer (0,0) Gluon)
True
λ> notGluon (Pointer a b)

<interactive>:3997:19: error:
    Variable not in scope: a :: (Int, Int)

<interactive>:3997:21: error: Variable not in scope: b :: IndexType
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:58:18-24: error:
    Not in scope: data constructor ‘Pointer’
    Perhaps you meant variable ‘pointers’ (line 53)
   |
58 |     pointsSame0 (Pointer vals0 _) (Pointer vals1 _) = fst vals0 == fst vals1
   |                  ^^^^^^^

tensor-map.hs:58:36-42: error:
    Not in scope: data constructor ‘Pointer’
    Perhaps you meant variable ‘pointers’ (line 53)
   |
58 |     pointsSame0 (Pointer vals0 _) (Pointer vals1 _) = fst vals0 == fst vals1
   |                                    ^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:31:5-11: error:
    • Couldn't match expected type ‘Bool’ with actual type ‘Pointer’
    • In the expression: Gluon _
      In a stmt of a pattern guard for
                     an equation for ‘isGluon’:
        Gluon _
      In an equation for ‘isGluon’:
          isGluon edgeType idxs
            | Gluon _ = True
            | otherwise = False
   |
31 |   | Gluon _ = True
   |     ^^^^^^^

tensor-map.hs:31:11: error:
    • Found hole: _ :: (Int, Int)
    • In the first argument of ‘Gluon’, namely ‘_’
      In the expression: Gluon _
      In a stmt of a pattern guard for
                     an equation for ‘isGluon’:
        Gluon _
    • Relevant bindings include
        idxs :: p1 (bound at tensor-map.hs:30:18)
        edgeType :: p (bound at tensor-map.hs:30:9)
        isGluon :: p -> p1 -> Bool (bound at tensor-map.hs:30:1)
      Valid substitutions include
        undefined :: forall (a :: TYPE r).
                     GHC.Stack.Types.HasCallStack =>
                     a
          (imported from ‘Prelude’ at tensor-map.hs:1:1
           (and originally defined in ‘GHC.Err’))
        maxBound :: forall a. Bounded a => a
          (imported from ‘Prelude’ at tensor-map.hs:1:1
           (and originally defined in ‘GHC.Enum’))
        minBound :: forall a. Bounded a => a
          (imported from ‘Prelude’ at tensor-map.hs:1:1
           (and originally defined in ‘GHC.Enum’))
   |
31 |   | Gluon _ = True
   |           ^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> isGluon 1

<interactive>:4138:9: error:
    • No instance for (Num Pointer) arising from the literal ‘1’
    • In the first argument of ‘isGluon’, namely ‘1’
      In the expression: isGluon 1
      In an equation for ‘it’: it = isGluon 1
λ> isGluon Up (1,1)

<interactive>:4139:1-16: error:
    • Couldn't match expected type ‘(Integer, Integer) -> t’
                  with actual type ‘Bool’
    • The function ‘isGluon’ is applied to two arguments,
      but its type ‘Pointer -> Bool’ has only one
      In the expression: isGluon Up (1, 1)
      In an equation for ‘it’: it = isGluon Up (1, 1)
    • Relevant bindings include it :: t (bound at <interactive>:4139:1)

<interactive>:4139:9-10: error:
    • Couldn't match expected type ‘Pointer’
                  with actual type ‘(Int, Int) -> Pointer’
    • Probable cause: ‘Up’ is applied to too few arguments
      In the first argument of ‘isGluon’, namely ‘Up’
      In the expression: isGluon Up (1, 1)
      In an equation for ‘it’: it = isGluon Up (1, 1)
λ> isGluon (Up (1,1))
*** Exception: tensor-map.hs:(30,1)-(31,21): Non-exhaustive patterns in function isGluon

λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:31:6-12: error:
    • Couldn't match expected type ‘Bool’ with actual type ‘Pointer’
    • In the expression: (Gluon _)
      In a stmt of a pattern guard for
                     an equation for ‘isGluon’:
        (Gluon _)
      In an equation for ‘isGluon’:
          isGluon a
            | (Gluon _) = True
            | otherwise = False
   |
31 |   | (Gluon _) = True
   |      ^^^^^^^

tensor-map.hs:31:12: error:
    • Found hole: _ :: (Int, Int)
    • In the first argument of ‘Gluon’, namely ‘_’
      In the expression: (Gluon _)
      In a stmt of a pattern guard for
                     an equation for ‘isGluon’:
        (Gluon _)
    • Relevant bindings include
        a :: p (bound at tensor-map.hs:30:9)
        isGluon :: p -> Bool (bound at tensor-map.hs:30:1)
      Valid substitutions include
        undefined :: forall (a :: TYPE r).
                     GHC.Stack.Types.HasCallStack =>
                     a
          (imported from ‘Prelude’ at tensor-map.hs:1:1
           (and originally defined in ‘GHC.Err’))
        maxBound :: forall a. Bounded a => a
          (imported from ‘Prelude’ at tensor-map.hs:1:1
           (and originally defined in ‘GHC.Enum’))
        minBound :: forall a. Bounded a => a
          (imported from ‘Prelude’ at tensor-map.hs:1:1
           (and originally defined in ‘GHC.Enum’))
   |
31 |   | (Gluon _) = True
   |            ^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> isGluon 1

<interactive>:4167:9: error:
    • No instance for (Num Pointer) arising from the literal ‘1’
    • In the first argument of ‘isGluon’, namely ‘1’
      In the expression: isGluon 1
      In an equation for ‘it’: it = isGluon 1
λ> isGluon (Gluon 1)

<interactive>:4168:16: error:
    • No instance for (Num (Int, Int)) arising from the literal ‘1’
    • In the first argument of ‘Gluon’, namely ‘1’
      In the first argument of ‘isGluon’, namely ‘(Gluon 1)’
      In the expression: isGluon (Gluon 1)
λ> isGluon (Gluon (1,1))
True
λ> isGluon (Up, (1,1))

<interactive>:4170:9-19: error:
    • Couldn't match expected type ‘Pointer’
                  with actual type ‘((Int, Int) -> Pointer, (Integer, Integer))’
    • In the first argument of ‘isGluon’, namely ‘(Up, (1, 1))’
      In the expression: isGluon (Up, (1, 1))
      In an equation for ‘it’: it = isGluon (Up, (1, 1))
λ> isGluon (Up, (1,1))

<interactive>:4171:9-19: error:
    • Couldn't match expected type ‘Pointer’
                  with actual type ‘((Int, Int) -> Pointer, (Integer, Integer))’
    • In the first argument of ‘isGluon’, namely ‘(Up, (1, 1))’
      In the expression: isGluon (Up, (1, 1))
      In an equation for ‘it’: it = isGluon (Up, (1, 1))
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> isGluon (Up, (1,1))

<interactive>:4173:9-19: error:
    • Couldn't match expected type ‘Pointer’
                  with actual type ‘((Int, Int) -> Pointer, (Integer, Integer))’
    • In the first argument of ‘isGluon’, namely ‘(Up, (1, 1))’
      In the expression: isGluon (Up, (1, 1))
      In an equation for ‘it’: it = isGluon (Up, (1, 1))
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> isGluon (Up, (1,1))

<interactive>:4179:9-19: error:
    • Couldn't match expected type ‘Pointer’
                  with actual type ‘((Int, Int) -> Pointer, (Integer, Integer))’
    • In the first argument of ‘isGluon’, namely ‘(Up, (1, 1))’
      In the expression: isGluon (Up, (1, 1))
      In an equation for ‘it’: it = isGluon (Up, (1, 1))
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> isGluon (Up, (1,1))

<interactive>:4181:9-19: error:
    • Couldn't match expected type ‘Pointer’
                  with actual type ‘((Int, Int) -> Pointer, (Integer, Integer))’
    • In the first argument of ‘isGluon’, namely ‘(Up, (1, 1))’
      In the expression: isGluon (Up, (1, 1))
      In an equation for ‘it’: it = isGluon (Up, (1, 1))
λ> isGluon (Gluon (1,1))
True
λ> isGluon (Up (1,1))
False
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> isGluon (Up (1,1))
False
λ> :t is

<interactive>:1:1-2: error:
    • Variable not in scope: is
    • Perhaps you meant one of these:
        ‘id’ (imported from Prelude), ‘it’ (line 4186)
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:34:37-40: error:
    • Couldn't match expected type ‘bool’ with actual type ‘Bool’
      ‘bool’ is a rigid type variable bound by
        the type signature for:
          typeCompare :: forall bool. Pointer -> Pointer -> bool
        at tensor-map.hs:34:3-13
    • In the expression: True
      In an equation for ‘typeCompare’:
          typeCompare (Gluon _) (Gluon _) = True
      In the instance declaration for ‘Compare Pointer’
    • Relevant bindings include
        typeCompare :: Pointer -> Pointer -> bool
          (bound at tensor-map.hs:34:3)
   |
34 |   typeCompare (Gluon _) (Gluon _) = True
   |                                     ^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> x = Gluon (1,1)
λ> y = Up (1,1)
λ> x == y
False
λ> x == x
True
λ> f (Tensor pointers) = Map.fromAscList pointers

<interactive>:4274:39-46: error:
    • Couldn't match expected type ‘[(k, a)]’
                  with actual type ‘Map Int Pointer’
    • In the first argument of ‘Map.fromAscList’, namely ‘pointers’
      In the expression: Map.fromAscList pointers
      In an equation for ‘f’:
          f (Tensor pointers) = Map.fromAscList pointers
    • Relevant bindings include
        f :: Tensor -> Map k a (bound at <interactive>:4274:1)
λ> pointers

<interactive>:4275:1-8: error: Variable not in scope: pointers
λ> f (Tensor pointers) = [pointer | (_, pointer) <- Map.toAscList pointers]
λ> f t1
[(0,Gluon (0,2)),(1,Down (1,2)),(2,Up (1,1))]
λ> f (Tensor pointers) = [pointer | (_, pointer) <- Map.toAscList pointers]
λ> f t1
[Gluon (0,2),Down (1,2),Up (1,1)]
λ> filter isGluon $ f t1

<interactive>:4280:1-6: error:
    Ambiguous occurrence ‘filter’
    It could refer to either ‘Data.List.filter’,
                             imported from ‘Data.List’ (and originally defined in ‘GHC.List’)
                          or ‘Data.Map.filter’,
                             imported from ‘Data.Map’
                             (and originally defined in ‘Data.Map.Internal’)
λ> Data.List.filter isGluon $ f t1
[Gluon (0,2)]
λ> Data.List.filter (not isGluon) $ f t1

<interactive>:4282:19-29: error:
    • Couldn't match expected type ‘Pointer -> Bool’
                  with actual type ‘Bool’
    • Possible cause: ‘not’ is applied to too many arguments
      In the first argument of ‘Data.List.filter’, namely ‘(not isGluon)’
      In the expression: Data.List.filter (not isGluon)
      In the expression: Data.List.filter (not isGluon) $ f t1

<interactive>:4282:23-29: error:
    • Couldn't match expected type ‘Bool’
                  with actual type ‘Pointer -> Bool’
    • Probable cause: ‘isGluon’ is applied to too few arguments
      In the first argument of ‘not’, namely ‘isGluon’
      In the first argument of ‘Data.List.filter’, namely ‘(not isGluon)’
      In the expression: Data.List.filter (not isGluon)
λ> not
not :: Bool -> Bool
λ> negate

<interactive>:4285:1-6: error:
    Ambiguous occurrence ‘negate’
    It could refer to either ‘Prelude.negate’,
                             imported from ‘Prelude’ at tensor-map.hs:1:1
                             (and originally defined in ‘GHC.Num’)
                          or ‘LP.negate’,
                             imported from ‘MathObj.LaurentPolynomial’ at tensor-map.hs:3:1-38
λ> Data.List.filterNot isGluon $ f t1

<interactive>:4286:1-19: error:
    Not in scope: ‘Data.List.filterNot’
    Perhaps you meant one of these:
      ‘Data.List.filter’ (imported from Data.List),
      ‘Data.List.filter’ (imported from Data.List),
      ‘Data.List.iterate’ (imported from Data.List)
    No module named ‘Data.List’ is imported.
λ> pred
pred :: Enum a => a -> a
λ> not . isGluon
not . isGluon :: Pointer -> Bool
λ> .

<interactive>:4291:1: error: parse error on input ‘.’
λ> :t .

<interactive>:1:1: error: parse error on input ‘.’
λ> Data.List.filter (not . isGluon) $ f t1
[Down (1,2),Up (1,1)]
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:34:30-35: error:
    Ambiguous occurrence ‘filter’
    It could refer to either ‘Prelude.filter’,
                             imported from ‘Prelude’ at tensor-map.hs:1:1
                             (and originally defined in ‘GHC.List’)
                          or ‘Map.filter’,
                             imported from ‘Data.Map.Strict’ at tensor-map.hs:1:1-29
                             (and originally defined in ‘Data.Map.Internal’)
   |
34 | nonGluonPointers (Tensor ) = filter (not . isGluon) $ f t
   |                              ^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> nonGluonPointers t1
[Down (1,2),Up (1,1)]
λ> nonGluonPointers t2

<interactive>:4377:18-19: error:
    • Variable not in scope: t2 :: Tensor
    • Perhaps you meant one of these: ‘t1’ (line 23), ‘t0’ (line 17)
λ> nonGluonPointers t0
[Down (0,1),Up (0,0)]
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:4:83-84: error:
    Duplicate instance declarations:
      instance Eq Pointer -- Defined at tensor-map.hs:4:83
      instance Eq Pointer -- Defined at tensor-map.hs:29:10
  |
4 | data Pointer = Up (Int, Int) | Down (Int, Int) | Gluon (Int, Int) deriving (Show, Eq)
  |                                                                                   ^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> (Up (1,1)) == (Up (0,0))
True
λ> (Gluon (1,1)) == (Up (1,1))
False
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:33:32-35: error:
    • Couldn't match expected type ‘bool’ with actual type ‘Bool’
      ‘bool’ is a rigid type variable bound by
        the type signature for:
          edgeEq :: forall bool. Pointer -> Pointer -> bool
        at tensor-map.hs:33:3-8
    • In the expression: True
      In an equation for ‘edgeEq’: edgeEq (Gluon _) (Gluon _) = True
      In the instance declaration for ‘EqEdgeType Pointer’
    • Relevant bindings include
        edgeEq :: Pointer -> Pointer -> bool (bound at tensor-map.hs:33:3)
   |
33 |   edgeEq (Gluon _) (Gluon _) = True
   |                                ^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> edgeEq (Up (1,1)) (Up (0,0))
True
λ> edgeEq (Up (1,1)) (Gluon (0,0))
False
λ> edgeEq (Up a) (Gluon (0,0))

<interactive>:4531:12: error:
    Variable not in scope: a :: (Int, Int)
λ> edgeEq (Up _) (Gluon (0,0))

<interactive>:1:1: error:
    GHC internal error: ‘Ghci1.it’ is not in scope during type checking, but it passed the renamer
    tcl_env of environment: []
λ> edgeEq (Up 1) (Gluon (0,0))

<interactive>:4533:12: error:
    • No instance for (Num (Int, Int)) arising from the literal ‘1’
    • In the first argument of ‘Up’, namely ‘1’
      In the first argument of ‘edgeEq’, namely ‘(Up 1)’
      In the expression: edgeEq (Up 1) (Gluon (0, 0))
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:33:10-27: warning: [-Wmissing-methods]
    • No explicit implementation for
        ‘isEdge’
    • In the instance declaration for ‘EqEdgeType Pointer’
   |
33 | instance EqEdgeType Pointer where
   |          ^^^^^^^^^^^^^^^^^^
Ok, one module loaded.
Collecting type info for 1 module(s) ... 

tensor-map.hs:33:10-27: warning: [-Wmissing-methods]
    • No explicit implementation for
        ‘isEdge’
    • In the instance declaration for ‘EqEdgeType Pointer’
   |
33 | instance EqEdgeType Pointer where
   |          ^^^^^^^^^^^^^^^^^^
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> nonGluonPointers t1
[Down (1,2),Up (1,1)]
λ> nonGluonPointers t2

<interactive>:4560:18-19: error:
    • Variable not in scope: t2 :: Tensor
    • Perhaps you meant one of these: ‘t1’ (line 23), ‘t0’ (line 17)
λ> nonGluonPointers t0
[Down (0,1),Up (0,0)]
λ> comapre

<interactive>:4569:1-7: error:
    • Variable not in scope: comapre
    • Perhaps you meant ‘compare’ (imported from Prelude)
λ> compare
compare :: Ord a => a -> a -> Ordering
λ> on

<interactive>:4572:1-2: error:
    • Variable not in scope: on
    • Perhaps you meant ‘or’ (imported from Data.List)
λ> (compare `on` edgeEq)

<interactive>:4573:10-13: error:
    • Variable not in scope:
        on :: (() -> () -> Ordering) -> (a0 -> a0 -> Bool) -> t
    • Perhaps you meant ‘or’ (imported from Data.List)
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> (compare `on` edgeEq)

<interactive>:4587:10-13: error:
    • Variable not in scope:
        on :: (() -> () -> Ordering) -> (a0 -> a0 -> Bool) -> t
    • Perhaps you meant ‘or’ (imported from Data.List)
λ> :t on

<interactive>:1:1-2: error:
    • Variable not in scope: on
    • Perhaps you meant ‘or’ (imported from Data.List)
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> (compare `on` edgeEq)

<interactive>:4601:1-21: error:
    • Non type-variable argument in the constraint: Ord (a -> Bool)
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        it :: forall a.
              (Ord (a -> Bool), EqEdgeType a) =>
              a -> a -> Ordering
λ> edgeEq
edgeEq :: EqEdgeType a => a -> a -> Bool
λ> compare
compare :: Ord a => a -> a -> Ordering
λ> nonGluonPointers t1
[Down (1,2),Up (1,1)]
λ> x = nonGluonPointers t1
λ> y = nonGluonPointers t0
λ> x == y

<interactive>:4609:1-6: error:
    • No instance for (Eq Pointer) arising from a use of ‘==’
    • In the expression: x == y
      In an equation for ‘it’: it = x == y
λ> edgeEq x y

<interactive>:4610:1-10: error:
    • No instance for (EqEdgeType [Pointer])
        arising from a use of ‘edgeEq’
    • In the expression: edgeEq x y
      In an equation for ‘it’: it = edgeEq x y
λ> map $ edgeEq $ x y

<interactive>:4611:1-3: error:
    Ambiguous occurrence ‘map’
    It could refer to either ‘Data.List.map’,
                             imported from ‘Data.List’ (and originally defined in ‘GHC.Base’)
                          or ‘Map.map’,
                             imported from ‘Data.Map.Strict’ at tensor-map.hs:3:1-29
                             (and originally defined in ‘Data.Map.Strict.Internal’)
                          or ‘Data.Map.map’,
                             imported from ‘Data.Map’
                             (and originally defined in ‘Data.Map.Internal’)
λ> x
[Down (1,2),Up (1,1)]
λ> y
[Down (0,1),Up (0,0)]
λ> [edgeEq(x,y) | (x, y) <- zip(x, y)]

<interactive>:4614:26-34: error:
    • Couldn't match expected type ‘[(a, b)]’
                  with actual type ‘[b0] -> [(a0, b0)]’
    • Probable cause: ‘zip’ is applied to too few arguments
      In the expression: zip (x, y)
      In a stmt of a list comprehension: (x, y) <- zip (x, y)
      In the expression: [edgeEq (x, y) | (x, y) <- zip (x, y)]
    • Relevant bindings include
        it :: [(a, b) -> Bool] (bound at <interactive>:4614:1)

<interactive>:4614:29-34: error:
    • Couldn't match expected type ‘[a0]’
                  with actual type ‘([Pointer], [Pointer])’
    • In the first argument of ‘zip’, namely ‘(x, y)’
      In the expression: zip (x, y)
      In a stmt of a list comprehension: (x, y) <- zip (x, y)
λ> f x y = [edgeEq(x,y) | (x, y) <- zip(x, y)]

<interactive>:4615:34-42: error:
    • Couldn't match expected type ‘[(a1, b1)]’
                  with actual type ‘[b0] -> [(a0, b0)]’
    • Probable cause: ‘zip’ is applied to too few arguments
      In the expression: zip (x, y)
      In a stmt of a list comprehension: (x, y) <- zip (x, y)
      In the expression: [edgeEq (x, y) | (x, y) <- zip (x, y)]
    • Relevant bindings include
        f :: a -> b -> [(a1, b1) -> Bool] (bound at <interactive>:4615:1)

<interactive>:4615:37-42: error:
    • Couldn't match expected type ‘[a0]’ with actual type ‘(a, b)’
    • In the first argument of ‘zip’, namely ‘(x, y)’
      In the expression: zip (x, y)
      In a stmt of a list comprehension: (x, y) <- zip (x, y)
    • Relevant bindings include
        y :: b (bound at <interactive>:4615:5)
        x :: a (bound at <interactive>:4615:3)
        f :: a -> b -> [(a1, b1) -> Bool] (bound at <interactive>:4615:1)
λ> [edgeEq(i,j) | (i, j) <- zip(x, y)]

<interactive>:4616:26-34: error:
    • Couldn't match expected type ‘[(a, b)]’
                  with actual type ‘[b0] -> [(a0, b0)]’
    • Probable cause: ‘zip’ is applied to too few arguments
      In the expression: zip (x, y)
      In a stmt of a list comprehension: (i, j) <- zip (x, y)
      In the expression: [edgeEq (i, j) | (i, j) <- zip (x, y)]
    • Relevant bindings include
        it :: [(a, b) -> Bool] (bound at <interactive>:4616:1)

<interactive>:4616:29-34: error:
    • Couldn't match expected type ‘[a0]’
                  with actual type ‘([Pointer], [Pointer])’
    • In the first argument of ‘zip’, namely ‘(x, y)’
      In the expression: zip (x, y)
      In a stmt of a list comprehension: (i, j) <- zip (x, y)
λ> f x y = [ (i, j) | <- zip x y]

<interactive>:4618:20-21: error:
    parse error on input ‘<-’
    Perhaps this statement should be within a 'do' block?
λ> f x y = [ (i, j) | (i, j)<- zip x y]
λ> x
[Down (1,2),Up (1,1)]
λ> f x y
[(Down (1,2),Down (0,1)),(Up (1,1),Up (0,0))]
λ> f x y = [ 0 | (i, j)<- zip x y, edgeEq i j]
λ> f x y
[(Down (1,2),Down (0,1)),(Up (1,1),Up (0,0))]
λ> f x y = [ 0 | (i, j)<- zip x y, edgeEq i j]
λ> f x y
[0,0]
λ> f x y = length x == length [ 0 | (i, j)<- zip x y, edgeEq i j]
λ> f x y
True
λ> x 
[Down (1,2),Up (1,1)]
λ> y 
[Down (0,1),Up (0,0)]
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> p1Compatible t0 t1
True
λ> p1Compatible t0 t0
True
λ> :l tensor-map.hs
[1 of 1] Compiling Main             ( tensor-map.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> p1Compatible t0 t2
False
λ> p1Compatible t0 t1
True
λ> p1Compatible t3 t3

<interactive>:4714:14-15: error:
    • Variable not in scope: t3 :: Tensor
    • Perhaps you meant one of these:
        ‘t1’ (line 25), ‘t2’ (line 31), ‘t0’ (line 19)

<interactive>:4714:17-18: error:
    • Variable not in scope: t3 :: Tensor
    • Perhaps you meant one of these:
        ‘t1’ (line 25), ‘t2’ (line 31), ‘t0’ (line 19)
λ> p1Compatible t2 t2
True
λ> :l tensor-map.hs

Tensor.hs:1:1: error:
    File name does not match module name:
    Saw: ‘Main’
    Expected: ‘Tensor’
  |
1 | import Data.List
  | ^
Failed, no modules loaded.
λ> :l Tensor.hs
[1 of 1] Compiling Tensor           ( Tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:3:15-29: error:
    Not in scope: ‘Map.fromAscList’
    No module named ‘Map’ is imported.
  |
3 | t0 = Tensor $ Map.fromAscList $ zip [0,1..] [
  |               ^^^^^^^^^^^^^^^

tensor-map.hs:9:15-29: error:
    Not in scope: ‘Map.fromAscList’
    No module named ‘Map’ is imported.
  |
9 | t1 = Tensor $ Map.fromAscList $ zip [0,1..] [
  |               ^^^^^^^^^^^^^^^

tensor-map.hs:15:15-29: error:
    Not in scope: ‘Map.fromAscList’
    No module named ‘Map’ is imported.
   |
15 | t2 = Tensor $ Map.fromAscList $ zip [0,1..] [
   |               ^^^^^^^^^^^^^^^

tensor-map.hs:22:21-35: error:
    Not in scope: ‘Map.fromAscList’
    No module named ‘Map’ is imported.
   |
22 | tensors = Tensors $ Map.fromAscList $ zip [0,1..] [t0, t1]
   |                     ^^^^^^^^^^^^^^^
Failed, one module loaded.
λ> :l Tensor.hs
[1 of 1] Compiling Tensor           ( Tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:3:15-29: error:
    Not in scope: ‘Map.fromAscList’
    No module named ‘Map’ is imported.
  |
3 | t0 = Tensor $ Map.fromAscList $ zip [0,1..] [
  |               ^^^^^^^^^^^^^^^

tensor-map.hs:9:15-29: error:
    Not in scope: ‘Map.fromAscList’
    No module named ‘Map’ is imported.
  |
9 | t1 = Tensor $ Map.fromAscList $ zip [0,1..] [
  |               ^^^^^^^^^^^^^^^

tensor-map.hs:15:15-29: error:
    Not in scope: ‘Map.fromAscList’
    No module named ‘Map’ is imported.
   |
15 | t2 = Tensor $ Map.fromAscList $ zip [0,1..] [
   |               ^^^^^^^^^^^^^^^

tensor-map.hs:22:21-35: error:
    Not in scope: ‘Map.fromAscList’
    No module named ‘Map’ is imported.
   |
22 | tensors = Tensors $ Map.fromAscList $ zip [0,1..] [t0, t1]
   |                     ^^^^^^^^^^^^^^^
Failed, one module loaded.
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:4:6-11: error:
    • Data constructor not in scope: Tensor :: Map Integer a2 -> t
    • Perhaps you meant variable ‘tensors’ (line 23)
  |
4 | t0 = Tensor $ Map.fromAscList $ zip [0,1..] [
  |      ^^^^^^

tensor-map.hs:5:4-7: error:
    Data constructor not in scope: Down :: (Integer, Integer) -> a2
  |
5 |    Down (0,1),
  |    ^^^^

tensor-map.hs:6:4-5: error:
    Data constructor not in scope: Up :: (Integer, Integer) -> a2
  |
6 |    Up (0,0),
  |    ^^

tensor-map.hs:7:4-8: error:
    Data constructor not in scope: Gluon :: (Integer, Integer) -> a2
  |
7 |    Gluon (1,0)
  |    ^^^^^

tensor-map.hs:10:6-11: error:
    • Data constructor not in scope: Tensor :: Map Integer a1 -> t
    • Perhaps you meant variable ‘tensors’ (line 23)
   |
10 | t1 = Tensor $ Map.fromAscList $ zip [0,1..] [
   |      ^^^^^^

tensor-map.hs:11:4-8: error:
    Data constructor not in scope: Gluon :: (Integer, Integer) -> a1
   |
11 |    Gluon (0,2),
   |    ^^^^^

tensor-map.hs:12:4-7: error:
    Data constructor not in scope: Down :: (Integer, Integer) -> a1
   |
12 |    Down (1,2),
   |    ^^^^

tensor-map.hs:13:4-5: error:
    Data constructor not in scope: Up :: (Integer, Integer) -> a1
   |
13 |    Up (1,1)
   |    ^^

tensor-map.hs:16:6-11: error:
    • Data constructor not in scope: Tensor :: Map Integer a0 -> t
    • Perhaps you meant variable ‘tensors’ (line 23)
   |
16 | t2 = Tensor $ Map.fromAscList $ zip [0,1..] [
   |      ^^^^^^

tensor-map.hs:17:4-8: error:
    Data constructor not in scope: Gluon :: (Integer, Integer) -> a0
   |
17 |    Gluon (0,2),
   |    ^^^^^

tensor-map.hs:18:4-5: error:
    Data constructor not in scope: Up :: (Integer, Integer) -> a0
   |
18 |    Up (1,2),
   |    ^^

tensor-map.hs:19:4-7: error:
    Data constructor not in scope: Down :: (Integer, Integer) -> a0
   |
19 |    Down (1,1)
   |    ^^^^

tensor-map.hs:22:12-21: error:
    Variable not in scope: fromCoeffs :: [Integer] -> t
   |
22 | identity = fromCoeffs [1]
   |            ^^^^^^^^^^

tensor-map.hs:23:11-17: error:
    • Data constructor not in scope: Tensors :: Map Integer a3 -> t
    • Perhaps you meant variable ‘tensors’ (line 23)
   |
23 | tensors = Tensors $ Map.fromAscList $ zip [0,1..] [t0, t1]
   |           ^^^^^^^

tensor-map.hs:24:11-23: error:
    Data constructor not in scope: TensorProduct :: t0 -> t1 -> t
   |
24 | dumbell = TensorProduct identity tensors
   |           ^^^^^^^^^^^^^
Failed, one module loaded.
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:4:6-11: error:
    • Data constructor not in scope: Tensor :: Map Integer a2 -> t
    • Perhaps you meant variable ‘tensors’ (line 23)
  |
4 | t0 = Tensor $ Map.fromAscList $ zip [0,1..] [
  |      ^^^^^^

tensor-map.hs:5:4-7: error:
    Data constructor not in scope: Down :: (Integer, Integer) -> a2
  |
5 |    Down (0,1),
  |    ^^^^

tensor-map.hs:6:4-5: error:
    Data constructor not in scope: Up :: (Integer, Integer) -> a2
  |
6 |    Up (0,0),
  |    ^^

tensor-map.hs:7:4-8: error:
    Data constructor not in scope: Gluon :: (Integer, Integer) -> a2
  |
7 |    Gluon (1,0)
  |    ^^^^^

tensor-map.hs:10:6-11: error:
    • Data constructor not in scope: Tensor :: Map Integer a1 -> t
    • Perhaps you meant variable ‘tensors’ (line 23)
   |
10 | t1 = Tensor $ Map.fromAscList $ zip [0,1..] [
   |      ^^^^^^

tensor-map.hs:11:4-8: error:
    Data constructor not in scope: Gluon :: (Integer, Integer) -> a1
   |
11 |    Gluon (0,2),
   |    ^^^^^

tensor-map.hs:12:4-7: error:
    Data constructor not in scope: Down :: (Integer, Integer) -> a1
   |
12 |    Down (1,2),
   |    ^^^^

tensor-map.hs:13:4-5: error:
    Data constructor not in scope: Up :: (Integer, Integer) -> a1
   |
13 |    Up (1,1)
   |    ^^

tensor-map.hs:16:6-11: error:
    • Data constructor not in scope: Tensor :: Map Integer a0 -> t
    • Perhaps you meant variable ‘tensors’ (line 23)
   |
16 | t2 = Tensor $ Map.fromAscList $ zip [0,1..] [
   |      ^^^^^^

tensor-map.hs:17:4-8: error:
    Data constructor not in scope: Gluon :: (Integer, Integer) -> a0
   |
17 |    Gluon (0,2),
   |    ^^^^^

tensor-map.hs:18:4-5: error:
    Data constructor not in scope: Up :: (Integer, Integer) -> a0
   |
18 |    Up (1,2),
   |    ^^

tensor-map.hs:19:4-7: error:
    Data constructor not in scope: Down :: (Integer, Integer) -> a0
   |
19 |    Down (1,1)
   |    ^^^^

tensor-map.hs:22:12-21: error:
    Variable not in scope: fromCoeffs :: [Integer] -> t
   |
22 | identity = fromCoeffs [1]
   |            ^^^^^^^^^^

tensor-map.hs:23:11-17: error:
    • Data constructor not in scope: Tensors :: Map Integer a3 -> t
    • Perhaps you meant variable ‘tensors’ (line 23)
   |
23 | tensors = Tensors $ Map.fromAscList $ zip [0,1..] [t0, t1]
   |           ^^^^^^^

tensor-map.hs:24:11-23: error:
    Data constructor not in scope: TensorProduct :: t0 -> t1 -> t
   |
24 | dumbell = TensorProduct identity tensors
   |           ^^^^^^^^^^^^^
Failed, one module loaded.
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:22:12-21: error:
    Variable not in scope: fromCoeffs :: [Integer] -> t
   |
22 | identity = fromCoeffs [1]
   |            ^^^^^^^^^^
Failed, one module loaded.
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:23:12-21: error:
    Variable not in scope: fromCoeffs :: [Integer] -> t
   |
23 | identity = fromCoeffs [1]
   |            ^^^^^^^^^^
Failed, one module loaded.
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> import tensor-map.hs

<interactive>:4921:8-13: error: parse error on input ‘tensor’
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> t1
Tensor (fromList [(0,Gluon (0,2)),(1,Down (1,2)),(2,Up (1,1))])
λ> t2
Tensor (fromList [(0,Gluon (0,2)),(1,Up (1,2)),(2,Down (1,1))])
λ> t3

<interactive>:4926:1-2: error:
    • Variable not in scope: t3
    • Perhaps you meant one of these:
        ‘t1’ (line 14), ‘t2’ (line 20), ‘t0’ (line 8)
λ> t0
Tensor (fromList [(0,Down (0,1)),(1,Up (0,0)),(2,Gluon (1,0))])
λ> t1
Tensor (fromList [(0,Gluon (0,2)),(1,Down (1,2)),(2,Up (1,1))])
λ> dumbell
TensorProduct (LaurentPolynomial.Cons 0 [1]) (Tensors (fromList [(0,Tensor (fromList [(0,Down (0,1)),(1,Up (0,0)),(2,Gluon (1,0))])),(1,Tensor (fromList [(0,Gluon (0,2)),(1,Down (1,2)),(2,Up (1,1))]))]))
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> p1Compatible t0 t1
True
λ> t0 t2

<interactive>:4934:1-5: error:
    • Couldn't match expected type ‘Tensor -> t’
                  with actual type ‘Tensor’
    • The function ‘t0’ is applied to one argument,
      but its type ‘Tensor’ has none
      In the expression: t0 t2
      In an equation for ‘it’: it = t0 t2
    • Relevant bindings include it :: t (bound at <interactive>:4934:1)
λ> t2
Tensor (fromList [(0,Gluon (0,2)),(1,Up (1,2)),(2,Down (1,1))])
λ> p1Compatible t0 t2
False
λ> :l Tensor.hs
[1 of 1] Compiling Tensor           ( Tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> pointers t1

<interactive>:5113:10-11: error:
    Variable not in scope: t1 :: Map Int Pointer
λ> t0

<interactive>:5114:1-2: error: Variable not in scope: t0
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> pointers t0

<interactive>:5117:10-11: error:
    • Couldn't match expected type ‘Map Int Pointer’
                  with actual type ‘Tensor’
    • In the first argument of ‘pointers’, namely ‘t0’
      In the expression: pointers t0
      In an equation for ‘it’: it = pointers t0
λ> to

<interactive>:5118:1-2: error:
    • Variable not in scope: to
    • Perhaps you meant one of these:
        ‘t1’ (line 14), ‘t2’ (line 20), ‘t0’ (line 8)
λ> t0
Tensor (fromList [(0,Down (0,1)),(1,Up (0,0)),(2,Gluon (1,0))])
λ> f (Tensor pointersMap) = pointers pointersMap
λ> f t1
[Gluon (0,2),Down (1,2),Up (1,1)]
λ> [ b | a b <- t1]

<interactive>:5124:7-9: error:
    Parse error in pattern: a
    Possibly caused by a missing 'do'?
λ> t1
Tensor (fromList [(0,Gluon (0,2)),(1,Down (1,2)),(2,Up (1,1))])
λ> [ b | a b <- f t1]

<interactive>:5126:7-9: error:
    Parse error in pattern: a
    Possibly caused by a missing 'do'?
λ> [ a | a <- f t1]
[Gluon (0,2),Down (1,2),Up (1,1)]
λ> [ a | (a b) <- f t1]

<interactive>:5128:8-10: error:
    Parse error in pattern: a
    Possibly caused by a missing 'do'?
λ> [ a | (_ (i,j)) <- f t1]

<interactive>:5129:8-14: error:
    Parse error in pattern: _
    Possibly caused by a missing 'do'?
λ> f :: Pointer -> (i,j)

<interactive>:5130:1: error:
    • Couldn't match type ‘[Pointer]’ with ‘(i1, j1)’
      Expected type: Pointer -> (i1, j1)
        Actual type: Tensor -> [Pointer]
    • In the expression: f :: Pointer -> (i, j)
      In an equation for ‘it’: it = f :: Pointer -> (i, j)
λ> f :: Pointer -> (Int, Int)

<interactive>:5131:1: error:
    • Couldn't match type ‘[Pointer]’ with ‘(Int, Int)’
      Expected type: Pointer -> (Int, Int)
        Actual type: Tensor -> [Pointer]
    • In the expression: f :: Pointer -> (Int, Int)
      In an equation for ‘it’: it = f :: Pointer -> (Int, Int)
λ> Pointer

<interactive>:5132:1-7: error:
    • Data constructor not in scope: Pointer
    • Perhaps you meant variable ‘pointers’ (imported from Tensor)
λ> :l Tensor.hs
[1 of 1] Compiling Tensor           ( Tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> f :: Pointer -> (Int, Int)

<interactive>:5135:1: error:
    Variable not in scope: f :: Pointer -> (Int, Int)
λ> f :: Pointer -> (a, a)

<interactive>:5136:1: error:
    Variable not in scope: f :: Pointer -> (a1, a1)
λ> :l scratch.hs
[1 of 1] Compiling Tensor           ( scratch.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> pointerVals (Pointer (1,2) Gluon)
(1,2)
λ> :l scratch.hs
[1 of 1] Compiling Tensor           ( scratch.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> isGluon (Pointer (1,2) Gluon)
True
λ> isGluon (Pointer (1,2) Up)
False
λ> :l Tensor.hs
[1 of 1] Compiling Tensor           ( Tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :l Tensor.hs
[1 of 1] Compiling Tensor           ( Tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> t1

<interactive>:5207:1-2: error: Variable not in scope: t1
λ> t0

<interactive>:5208:1-2: error: Variable not in scope: t0
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )

tensor-map.hs:9:4-13: error:
    • Couldn't match expected type ‘(Integer, Integer) -> Pointer’
                  with actual type ‘EdgeType’
    • The function ‘Down’ is applied to one argument,
      but its type ‘EdgeType’ has none
      In the expression: Down (0, 1)
      In the second argument of ‘zip’, namely
        ‘[Down (0, 1), Up (0, 0), Gluon (1, 0)]’
  |
9 |    Down (0,1),
  |    ^^^^^^^^^^

tensor-map.hs:10:4-11: error:
    • Couldn't match expected type ‘(Integer, Integer) -> Pointer’
                  with actual type ‘EdgeType’
    • The function ‘Up’ is applied to one argument,
      but its type ‘EdgeType’ has none
      In the expression: Up (0, 0)
      In the second argument of ‘zip’, namely
        ‘[Down (0, 1), Up (0, 0), Gluon (1, 0)]’
   |
10 |    Up (0,0),
   |    ^^^^^^^^

tensor-map.hs:11:4-14: error:
    • Couldn't match expected type ‘(Integer, Integer) -> Pointer’
                  with actual type ‘EdgeType’
    • The function ‘Gluon’ is applied to one argument,
      but its type ‘EdgeType’ has none
      In the expression: Gluon (1, 0)
      In the second argument of ‘zip’, namely
        ‘[Down (0, 1), Up (0, 0), Gluon (1, 0)]’
   |
11 |    Gluon (1,0)
   |    ^^^^^^^^^^^

tensor-map.hs:15:4-14: error:
    • Couldn't match expected type ‘(Integer, Integer) -> Pointer’
                  with actual type ‘EdgeType’
    • The function ‘Gluon’ is applied to one argument,
      but its type ‘EdgeType’ has none
      In the expression: Gluon (0, 2)
      In the second argument of ‘zip’, namely
        ‘[Gluon (0, 2), Down (1, 2), Up (1, 1)]’
   |
15 |    Gluon (0,2),
   |    ^^^^^^^^^^^

tensor-map.hs:16:4-13: error:
    • Couldn't match expected type ‘(Integer, Integer) -> Pointer’
                  with actual type ‘EdgeType’
    • The function ‘Down’ is applied to one argument,
      but its type ‘EdgeType’ has none
      In the expression: Down (1, 2)
      In the second argument of ‘zip’, namely
        ‘[Gluon (0, 2), Down (1, 2), Up (1, 1)]’
   |
16 |    Down (1,2),
   |    ^^^^^^^^^^

tensor-map.hs:17:4-11: error:
    • Couldn't match expected type ‘(Integer, Integer) -> Pointer’
                  with actual type ‘EdgeType’
    • The function ‘Up’ is applied to one argument,
      but its type ‘EdgeType’ has none
      In the expression: Up (1, 1)
      In the second argument of ‘zip’, namely
        ‘[Gluon (0, 2), Down (1, 2), Up (1, 1)]’
   |
17 |    Up (1,1)
   |    ^^^^^^^^

tensor-map.hs:21:4-14: error:
    • Couldn't match expected type ‘(Integer, Integer) -> Pointer’
                  with actual type ‘EdgeType’
    • The function ‘Gluon’ is applied to one argument,
      but its type ‘EdgeType’ has none
      In the expression: Gluon (0, 2)
      In the second argument of ‘zip’, namely
        ‘[Gluon (0, 2), Up (1, 2), Down (1, 1)]’
   |
21 |    Gluon (0,2),
   |    ^^^^^^^^^^^

tensor-map.hs:22:4-11: error:
    • Couldn't match expected type ‘(Integer, Integer) -> Pointer’
                  with actual type ‘EdgeType’
    • The function ‘Up’ is applied to one argument,
      but its type ‘EdgeType’ has none
      In the expression: Up (1, 2)
      In the second argument of ‘zip’, namely
        ‘[Gluon (0, 2), Up (1, 2), Down (1, 1)]’
   |
22 |    Up (1,2),
   |    ^^^^^^^^

tensor-map.hs:23:4-13: error:
    • Couldn't match expected type ‘(Integer, Integer) -> Pointer’
                  with actual type ‘EdgeType’
    • The function ‘Down’ is applied to one argument,
      but its type ‘EdgeType’ has none
      In the expression: Down (1, 1)
      In the second argument of ‘zip’, namely
        ‘[Gluon (0, 2), Up (1, 2), Down (1, 1)]’
   |
23 |    Down (1,1)
   |    ^^^^^^^^^^
Failed, one module loaded.
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> mappedKeys t0
[(0,1),(0,0),(1,0)]
λ> nub [0,1,1]
[0,1]
λ> nub [0,2,0,0,1,2,1]
[0,2,1]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> uniqueVsKeys t0
[0,1]
λ> tails [0,1,2,3]
[[0,1,2,3],[1,2,3],[2,3],[3],[]]
λ> x = tails [0,1,2,3]
λ> f l = [ (x,y) | (x:ys) <- tails l y <- ys]

<interactive>:5224:37-38: error:
    parse error on input ‘<-’
    Perhaps this statement should be within a 'do' block?
λ> f l = [ (x,y) | (x:ys) <- tails l, y <- ys]
λ> f [0,1,2]
[(0,1),(0,2),(1,2)]
λ> :l Tensor.hs
[1 of 1] Compiling Tensor           ( Tensor.hs, interpreted )

Tensor.hs:56:25: error: parse error on input ‘|’
   |
56 | f (Tensors tensorsMap)[ | tails $ Map.toAscList tensorsMap]
   |                         ^
Failed, no modules loaded.
λ> :l Tensor.hs
[1 of 1] Compiling Tensor           ( Tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> tensorsPairs tensors

<interactive>:5230:1-12: error:
    • Variable not in scope: tensorsPairs :: t0 -> t
    • Perhaps you meant ‘tensorPairs’ (line 52)

<interactive>:5230:14-20: error:
    • Variable not in scope: tensors
    • Perhaps you meant one of these:
        data constructor ‘Tensors’ (line 9),
        data constructor ‘Tensor’ (line 8)
λ> tensors

<interactive>:5231:1-7: error:
    • Variable not in scope: tensors
    • Perhaps you meant one of these:
        data constructor ‘Tensors’ (line 9),
        data constructor ‘Tensor’ (line 8)
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> tensors
Tensors (fromList [(0,Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)]))])
λ> tensorPairs tensors
[((0,Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)])))]
λ> :t map

<interactive>:1:1-3: error:
    Ambiguous occurrence ‘map’
    It could refer to either ‘Data.List.map’,
                             imported from ‘Data.List’ (and originally defined in ‘GHC.Base’)
                          or ‘Map.map’,
                             imported from ‘Data.Map.Strict’ at tensor-map.hs:2:1-29
                             (and originally defined in ‘Data.Map.Strict.Internal’)
                          or ‘Data.Map.map’,
                             imported from ‘Data.Map’
                             (and originally defined in ‘Data.Map.Internal’)
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> :l Tensor.hs
[1 of 1] Compiling Tensor           ( Tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> :l Tensor.hs
[1 of 1] Compiling Tensor           ( Tensor.hs, interpreted )

Tensor.hs:(58,1)-(62,11): error:
    Parse error: module header, import declaration
    or top-level declaration expected.
   |
58 | tensorPairs (Tensors tensorsMap)
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...
Failed, no modules loaded.
λ> :l Tensor.hs
[1 of 1] Compiling Tensor           ( Tensor.hs, interpreted )
Ok, one module loaded.
Collecting type info for 1 module(s) ... 
λ> tensors
tensors :: Tensors -> [Tensor]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> dumbellTensors
Tensors (fromList [(0,Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)]))])
λ> tensorPairs dumbellTensors
[((0,Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)])))]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> tensorPairs dumbellTensors
[(Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)]),Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)]))]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> map sunP1 $ tensorPairs dumbellTensors

<interactive>:5262:1-3: error:
    Ambiguous occurrence ‘map’
    It could refer to either ‘Data.List.map’,
                             imported from ‘Data.List’ (and originally defined in ‘GHC.Base’)
                          or ‘Map.map’,
                             imported from ‘Data.Map.Strict’ at tensor-map.hs:2:1-29
                             (and originally defined in ‘Data.Map.Strict.Internal’)
                          or ‘Data.Map.map’,
                             imported from ‘Data.Map’
                             (and originally defined in ‘Data.Map.Internal’)
λ> tensorPairs dumbellTensors
[(Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)]),Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)]))]
λ> length $ tensorPairs dumbellTensors
1
λ> Data.List.map sunP1 $ tensorPairs dumbellTensors
[True]
λ> :info tensorPairs
tensorPairs :: Tensors -> [(Tensor, Tensor)]
  	-- Defined at Tensor.hs:58:1
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )

Tensor.hs:47:7-14: error:
    • Couldn't match expected type ‘Tensor’
                  with actual type ‘(Tensor, Tensor)’
    • In the pattern: (t1, t2)
      In an equation for ‘sunP1’:
          sunP1 (t1, t2)
            = 2 == length [True | (i, j) <- zip x y, edgeEq i j]
            where
                x = nonGluonPointers t1
                y = nonGluonPointers t2
   |
47 | sunP1 (t1, t2) = 2 == length [ True | (i, j) <- zip x y, edgeEq i j]
   |       ^^^^^^^^

Tensor.hs:47:18-68: error:
    • Couldn't match expected type ‘Tensor -> Bool’
                  with actual type ‘Bool’
    • Possible cause: ‘(==)’ is applied to too many arguments
      In the expression:
        2 == length [True | (i, j) <- zip x y, edgeEq i j]
      In an equation for ‘sunP1’:
          sunP1 (t1, t2)
            = 2 == length [True | (i, j) <- zip x y, edgeEq i j]
            where
                x = nonGluonPointers t1
                y = nonGluonPointers t2
   |
47 | sunP1 (t1, t2) = 2 == length [ True | (i, j) <- zip x y, edgeEq i j]
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Tensor.hs:67:45-56: error:
    • Variable not in scope:
        tensorsPairs :: Tensors -> [(Tensor, Tensor)]
    • Perhaps you meant ‘tensorPairs’ (line 58)
   |
67 |     sunP1Tensors_ = [(t1, t2) | (t1, t2) <- tensorsPairs tensors, sunP1 t1 t2]
   |                                             ^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )

Tensor.hs:47:7-14: error:
    • Couldn't match expected type ‘Tensor’
                  with actual type ‘(Tensor, Tensor)’
    • In the pattern: (t1, t2)
      In an equation for ‘sunP1’:
          sunP1 (t1, t2)
            = 2 == length [True | (i, j) <- zip x y, edgeEq i j]
            where
                x = nonGluonPointers t1
                y = nonGluonPointers t2
   |
47 | sunP1 (t1, t2) = 2 == length [ True | (i, j) <- zip x y, edgeEq i j]
   |       ^^^^^^^^

Tensor.hs:47:18-68: error:
    • Couldn't match expected type ‘Tensor -> Bool’
                  with actual type ‘Bool’
    • Possible cause: ‘(==)’ is applied to too many arguments
      In the expression:
        2 == length [True | (i, j) <- zip x y, edgeEq i j]
      In an equation for ‘sunP1’:
          sunP1 (t1, t2)
            = 2 == length [True | (i, j) <- zip x y, edgeEq i j]
            where
                x = nonGluonPointers t1
                y = nonGluonPointers t2
   |
47 | sunP1 (t1, t2) = 2 == length [ True | (i, j) <- zip x y, edgeEq i j]
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
λ> sunP1Tensors_ = [(t1, t2) | (t1, t2) <- tensorPairs tensors, sunP1 t1 t2]

<interactive>:5275:41-51: error:
    Variable not in scope: tensorPairs :: t0 -> [(a, b)]

<interactive>:5275:53-59: error: Variable not in scope: tensors

<interactive>:5275:62-66: error:
    Variable not in scope: sunP1 :: a -> b -> Bool
λ> sunP1Tensors_ = [(t1, t2) | (t1, t2) <- tensorPairs dumbellTensors, sunP1 t1 t2]

<interactive>:5276:41-51: error:
    Variable not in scope: tensorPairs :: t0 -> [(a, b)]

<interactive>:5276:53-66: error:
    Variable not in scope: dumbellTensors

<interactive>:5276:69-73: error:
    Variable not in scope: sunP1 :: a -> b -> Bool
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> sunP1Tensors_ = [(t1, t2) | (t1, t2) <- tensorPairs dumbellTensors, sunP1 t1 t2]
λ> sunP1Tensors_
[(Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)]),Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)]))]
λ> length sunP1Tensors_
1
λ> head sunP1Tensors_
(Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)]),Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)]))
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> sunP1Tensors dumbellTensors
Just (Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)]),Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)]))
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> sunP1Tensors dumbellTensors

<interactive>:5291:1-12: error:
    Variable not in scope: sunP1Tensors :: Tensors -> t
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> dumbellTensors
Tensors (fromList [(0,Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)]))])
λ> sunP1Link dumbellTensors
Just ((0,Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)])))
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> p1Updates t1

<interactive>:5304:11-12: error:
    • Couldn't match expected type ‘Int’ with actual type ‘Tensor’
    • In the first argument of ‘p1Updates’, namely ‘t1’
      In the expression: p1Updates t1
      In an equation for ‘it’: it = p1Updates t1
λ> t0
Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])
λ> p1Updates 0 t1
[((0,0),(0,2)),((0,1),(1,2)),((0,2),(1,1))]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> p1Updates 0 t1
[((0,2),(1,1))]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )

Tensor.hs:81:47-93: error:
    Unexpected parallel statement in a list comprehension
    Use ParallelListComp
   |
81 |     p1Updates_ = [ ((vsIDX, tsIDX), (i, j)) | (tsIDX, (Pointer (i,j) a)) <- ps, a==Up|a==Down]
   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> p1Updates 0 t1
[((0,1),(1,2)),((0,2),(1,1))]
λ> p1Updates 0 t0
[((0,0),(0,1)),((0,1),(0,0))]
λ> p1Updates 0 t2
[((0,1),(1,2)),((0,2),(1,1))]
λ> p1Updates 0 t0
[((0,0),(0,1)),((0,1),(0,0))]
λ> p1Updates 0 t1
[((0,1),(1,2)),((0,2),(1,1))]
λ> p1Updates 1 t1
[((1,1),(1,2)),((1,2),(1,1))]
λ> sunP1Link dumbellTensors
Just ((0,Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)])))
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> sunP1Link dumbellTensors
Just ((0,Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)])))
λ> p1Updates $ head $ sunP1Link dumbellTensors

<interactive>:5321:20-43: error:
    • Couldn't match expected type ‘[(Int, Tensor)]’
                  with actual type ‘Maybe ((Int, Tensor), (Int, Tensor))’
    • In the second argument of ‘($)’, namely
        ‘sunP1Link dumbellTensors’
      In the second argument of ‘($)’, namely
        ‘head $ sunP1Link dumbellTensors’
      In the expression: p1Updates $ head $ sunP1Link dumbellTensors
λ> sunP1Link dumbellTensors
Just ((0,Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)])))
λ> head $ sunP1Link dumbellTensors

<interactive>:5325:8-31: error:
    • Couldn't match expected type ‘[a]’
                  with actual type ‘Maybe ((Int, Tensor), (Int, Tensor))’
    • In the second argument of ‘($)’, namely
        ‘sunP1Link dumbellTensors’
      In the expression: head $ sunP1Link dumbellTensors
      In an equation for ‘it’: it = head $ sunP1Link dumbellTensors
    • Relevant bindings include it :: a (bound at <interactive>:5325:1)
λ> sunP1Link dumbellTensors
Just ((0,Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)])))
λ> sunP1Link fst dumbellTensors

<interactive>:5327:1-28: error:
    • Couldn't match expected type ‘Tensors -> t’
                  with actual type ‘Maybe ((Int, Tensor), (Int, Tensor))’
    • The function ‘sunP1Link’ is applied to two arguments,
      but its type ‘Tensors -> Maybe ((Int, Tensor), (Int, Tensor))’
      has only one
      In the expression: sunP1Link fst dumbellTensors
      In an equation for ‘it’: it = sunP1Link fst dumbellTensors
    • Relevant bindings include it :: t (bound at <interactive>:5327:1)

<interactive>:5327:11-13: error:
    • Couldn't match expected type ‘Tensors’
                  with actual type ‘(a0, b0) -> a0’
    • Probable cause: ‘fst’ is applied to too few arguments
      In the first argument of ‘sunP1Link’, namely ‘fst’
      In the expression: sunP1Link fst dumbellTensors
      In an equation for ‘it’: it = sunP1Link fst dumbellTensors
λ> sunP1Link dumbellTensors
Just ((0,Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)])))
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )

Tensor.hs:85:53-59: error:
    • Couldn't match type ‘Pointer’ with ‘((Int, Int), (Int, Int))’
      Expected type: [((Int, Int), (Int, Int))]
        Actual type: [Pointer]
    • In the expression: updates
      In an equation for ‘p1UpdatesRHSOneElem’:
          p1UpdatesRHSOneElem (vsIDX, (Tensor pointersMap))
            = updates
            where
                ps = toAscList pointersMap
                updates
                  = [(Pointer (i, j) a) |
                       ((tsIDX, (Pointer (i, j) a)) : ys) <- tails ps,
                       y <- ys,
                       a == Up || a == Down]
   |
85 | p1UpdatesRHSOneElem (vsIDX, (Tensor pointersMap)) = updates
   |                                                     ^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> p1UpdatesRHSOneElem 0 t0

<interactive>:5331:1-24: error:
    • Couldn't match expected type ‘Tensor -> t’
                  with actual type ‘[Pointer]’
    • The function ‘p1UpdatesRHSOneElem’ is applied to two arguments,
      but its type ‘(a0, Tensor) -> [Pointer]’ has only one
      In the expression: p1UpdatesRHSOneElem 0 t0
      In an equation for ‘it’: it = p1UpdatesRHSOneElem 0 t0
    • Relevant bindings include it :: t (bound at <interactive>:5331:1)
λ> t0
Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])
λ> p1UpdatesRHSOneElem (0, t0,

<interactive>:5333:28: error:
    parse error (possibly incorrect indentation or mismatched brackets)
λ> p1UpdatesRHSOneElem (0, t0)
[Pointer (0,1) Down,Pointer (0,1) Down,Pointer (0,0) Up]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> p1UpdatesRHSOneElem (0, t0)
[(Pointer (0,1) Down,Pointer (0,0) Up),(Pointer (0,1) Down,Pointer (1,0) Gluon),(Pointer (0,0) Up,Pointer (1,0) Gluon)]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> p1UpdatesRHSOneElem (0, t0)
[(Pointer (0,1) Down,Pointer (0,0) Up),(Pointer (0,1) Down,Pointer (1,0) Gluon)]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> p1UpdatesRHSOneElem (0, t0)
[(Pointer (0,1) Down,Pointer (0,0) Up)]
λ> p1UpdatesLHS (0, t0)
[((0,0),(0,1)),((0,1),(0,0))]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> p1UpdatesRHSOneElem (0, t0)
[((0,1),(0,0))]
λ> [1,2,3] ++ [3,4,5]
[1,2,3,3,4,5]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> sunP1Link dumbellTensors
Just ((0,Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)])))
λ> p1UpdateRHS $ sunP1Link dumbellTensors

<interactive>:5349:1-11: error:
    • Variable not in scope:
        p1UpdateRHS :: Maybe ((Int, Tensor), (Int, Tensor)) -> t
    • Perhaps you meant one of these:
        ‘p1UpdatesRHS’ (imported from Tensor),
        ‘p1UpdatesLHS’ (imported from Tensor)
λ> Map.fromAscList []
fromList []
λ> Tensor Map.fromAscList []

<interactive>:5351:1-25: error:
    • Couldn't match expected type ‘[a1] -> t’
                  with actual type ‘Tensor’
    • The function ‘Tensor’ is applied to two arguments,
      but its type ‘Map Int Pointer -> Tensor’ has only one
      In the expression: Tensor Map.fromAscList []
      In an equation for ‘it’: it = Tensor Map.fromAscList []
    • Relevant bindings include it :: t (bound at <interactive>:5351:1)

<interactive>:5351:8-22: error:
    • Couldn't match expected type ‘Map Int Pointer’
                  with actual type ‘[((), a0)] -> Map () a0’
    • Probable cause: ‘Map.fromAscList’ is applied to too few arguments
      In the first argument of ‘Tensor’, namely ‘Map.fromAscList’
      In the expression: Tensor Map.fromAscList []
      In an equation for ‘it’: it = Tensor Map.fromAscList []
λ> fromList

<interactive>:5352:1-8: error:
    Ambiguous occurrence ‘fromList’
    It could refer to either ‘Map.fromList’,
                             imported from ‘Data.Map.Strict’ at tensor-map.hs:2:1-29
                             (and originally defined in ‘Data.Map.Strict.Internal’)
                          or ‘Data.Map.fromList’,
                             imported from ‘Data.Map’
                             (and originally defined in ‘Data.Map.Internal’)
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> wipeTensor dumbellTensors 0
Tensors (fromList [(0,Tensor (fromList [])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)]))])
λ> dumbellTensors
Tensors (fromList [(0,Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)]))])
λ> wipeTensor 1 $ wipeTensor dumbellTensors 0

<interactive>:5356:16-42: error:
    • Couldn't match expected type ‘Int’ with actual type ‘Tensors’
    • In the second argument of ‘($)’, namely
        ‘wipeTensor dumbellTensors 0’
      In the expression: wipeTensor 1 $ wipeTensor dumbellTensors 0
      In an equation for ‘it’:
          it = wipeTensor 1 $ wipeTensor dumbellTensors 0
λ> wipeTensor (wipeTensor dumbellTensors 0) 1
Tensors (fromList [(0,Tensor (fromList [])),(1,Tensor (fromList []))])
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> wipeTensors dumbellTensors [0]
Tensors (fromList [(0,Tensor (fromList [])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)]))])
λ> wipeTensors dumbellTensors [0, 1]
Tensors (fromList [(0,Tensor (fromList [])),(1,Tensor (fromList []))])
λ> :t Map

<interactive>:1:1-3: error:
    • Data constructor not in scope: Map
    • Perhaps you meant one of these:
        variable ‘map’ (imported from Data.List),
        variable ‘map’ (imported from Data.Map.Strict),
        variable ‘map’ (imported from Data.Map)
λ> :info Map
type role Map nominal representational
data Map k a
  = Data.Map.Internal.Bin {-# UNPACK #-}Data.Map.Internal.Size
                          !k
                          a
                          !(Map k a)
                          !(Map k a)
  | Data.Map.Internal.Tip
  	-- Defined in ‘Data.Map.Internal’
instance (Eq k, Eq a) => Eq (Map k a)
  -- Defined in ‘Data.Map.Internal’
instance Functor (Map k) -- Defined in ‘Data.Map.Internal’
instance Ord k => Monoid (Map k v)
  -- Defined in ‘Data.Map.Internal’
instance (Ord k, Ord v) => Ord (Map k v)
  -- Defined in ‘Data.Map.Internal’
instance Ord k => Semigroup (Map k v)
  -- Defined in ‘Data.Map.Internal’
instance (Show k, Show a) => Show (Map k a)
  -- Defined in ‘Data.Map.Internal’
instance (Ord k, Read k, Read e) => Read (Map k e)
  -- Defined in ‘Data.Map.Internal’
instance Foldable (Map k) -- Defined in ‘Data.Map.Internal’
instance Traversable (Map k) -- Defined in ‘Data.Map.Internal’
λ> t0
Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])
λ> f (Tensor pointersMap) = pointersMap
λ> :t f
f :: Tensor -> Map Int Pointer
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )

Tensor.hs:129:51-69: error:
    • Couldn't match expected type ‘Tensors’
                  with actual type ‘Map Int () -> Map Int ()’
    • Probable cause: ‘Map.insert’ is applied to too few arguments
      In the expression: Map.insert vsIDX ()
      In an equation for ‘rewire’:
          rewire (Tensors tensorsMap) ((vsIDX, pIDX), to)
            = Map.insert vsIDX ()
            where
                pointersMap = getTensorPointersMap
                tensor = Map.insert pIDX pointersMap
    |
129 | rewire (Tensors tensorsMap) ((vsIDX, pIDX), to) = Map.insert vsIDX ()
    |                                                   ^^^^^^^^^^^^^^^^^^^

Tensor.hs:131:19-38: error:
    Variable not in scope: getTensorPointersMap
    |
131 |     pointersMap = getTensorPointersMap
    |                   ^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> getPointersMap dumbellTensors 0
Just (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])
λ> Just 1
Just 1
λ> a = Just 1
λ> a >>= *2

<interactive>:5376:7: error: parse error on input ‘*’
λ> a >>= (*2)

<interactive>:5377:1-10: error:
    • Non type-variable argument in the constraint: Num (Maybe b)
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        it :: forall b. Num (Maybe b) => Maybe b
λ> a
Just 1
λ> a >>= (/x -> x*2)

<interactive>:5379:11-12: error: parse error on input ‘->’
λ> a >>= (\x -> x*2)

<interactive>:5380:1-17: error:
    • Non type-variable argument in the constraint: Num (Maybe b)
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        it :: forall b. Num (Maybe b) => Maybe b
λ> return a >> (\x -> x*2)
return a >> (\x -> x*2) :: Num b => b -> b
λ> return 1 >>= (\x -> x*2)

<interactive>:5383:1-24: error:
    • Ambiguous type variables ‘m0’, ‘b0’ arising from a use of ‘print’
      prevents the constraint ‘(Show (m0 b0))’ from being solved.
      Probable fix: use a type annotation to specify what ‘m0’,
                                                          ‘b0’ should be.
      These potential instances exist:
        instance (Show a, Show b) => Show (Either a b)
          -- Defined in ‘Data.Either’
        instance (Show k, Show a) => Show (Map k a)
          -- Defined in ‘Data.Map.Internal’
        instance Show a => Show (Newness a) -- Defined at Tensor.hs:5:47
        ...plus 17 others
        ...plus 61 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In a stmt of an interactive GHCi command: print it
λ> return 1 >>= (\x -> Just x*2)

<interactive>:5384:1-29: error:
    • Non type-variable argument in the constraint: Num (Maybe b)
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        it :: forall b. (Num b, Num (Maybe b)) => Maybe b
λ> a >>= (\x -> Just (x*2))
Just 2
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> getPointersMap dumbellTensors 0
Just (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])
λ> t1
Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)])
λ> f (Tensor pointersMap) = lookup 0 pointersMap

<interactive>:5395:26-31: error:
    Ambiguous occurrence ‘lookup’
    It could refer to either ‘Data.List.lookup’,
                             imported from ‘Data.List’ (and originally defined in ‘GHC.List’)
                          or ‘Data.Map.lookup’,
                             imported from ‘Data.Map’
                             (and originally defined in ‘Data.Map.Internal’)
λ> f (Tensor pointersMap) = Map.lookup 0 pointersMap
λ> f t0
Just (Pointer (0,1) Down)
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )

Tensor.hs:124:54-81: error:
    • Couldn't match expected type ‘(Int, Int) -> EdgeType -> Pointer’
                  with actual type ‘Maybe ((Int, Int) -> EdgeType -> Pointer)’
    • The function ‘Just’ is applied to three arguments,
      but its type ‘((Int, Int) -> EdgeType -> Pointer)
                    -> Maybe ((Int, Int) -> EdgeType -> Pointer)’
      has only one
      In the expression: Just Pointer (i, j) edgeType
      In an equation for ‘updatePointerAt’:
          updatePointerAt (Just (Pointer _ edgeType)) (i, j)
            = Just Pointer (i, j) edgeType
    |
124 | updatePointerAt (Just (Pointer _ edgeType)) (i, j) = Just Pointer (i, j) edgeType
    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> rewire dumbellTensors ((0,0),(1,1))
Just (Tensors (fromList [(0,Tensor (fromList [(0,Pointer (1,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)]))]))
λ> dumbellTensors
Tensors (fromList [(0,Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)]))])
λ> rewire dumbellTensors ((3,0),(1,1))
Nothing
λ> rewire dumbellTensors ((2,0),(9,9))
Nothing
λ> rewire dumbellTensors ((0,2),(9,9))
Just (Tensors (fromList [(0,Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (9,9) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)]))]))
λ> sunP1Link dumbellTensors
Just ((0,Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)])))
λ> p1UpdatesLHS dumbellTensors

<interactive>:5416:14-27: error:
    • Couldn't match expected type ‘(Int, Tensor)’
                  with actual type ‘Tensors’
    • In the first argument of ‘p1UpdatesLHS’, namely ‘dumbellTensors’
      In the expression: p1UpdatesLHS dumbellTensors
      In an equation for ‘it’: it = p1UpdatesLHS dumbellTensors
λ> p1UpdatesLHS t0

<interactive>:5418:14-15: error:
    • Couldn't match expected type ‘(Int, Tensor)’
                  with actual type ‘Tensor’
    • In the first argument of ‘p1UpdatesLHS’, namely ‘t0’
      In the expression: p1UpdatesLHS t0
      In an equation for ‘it’: it = p1UpdatesLHS t0
λ> p1UpdatesLHS (0,t0)
[((0,0),(0,1)),((0,1),(0,0))]
λ> links = p1UpdatesLHS (0, t0)
λ> re

<interactive>:5422:1-2: error:
    • Variable not in scope: re
    • Perhaps you meant ‘rem’ (imported from Prelude)
λ> rewire (Just dumbellTensors) links

<interactive>:5425:9-27: error:
    • Couldn't match expected type ‘Tensors’
                  with actual type ‘Maybe Tensors’
    • In the first argument of ‘rewire’, namely ‘(Just dumbellTensors)’
      In the expression: rewire (Just dumbellTensors) links
      In an equation for ‘it’: it = rewire (Just dumbellTensors) links

<interactive>:5425:30-34: error:
    • Couldn't match expected type ‘((Int, Int), (Int, Int))’
                  with actual type ‘[((Int, Int), (Int, Int))]’
    • In the second argument of ‘rewire’, namely ‘links’
      In the expression: rewire (Just dumbellTensors) links
      In an equation for ‘it’: it = rewire (Just dumbellTensors) links
λ> :t links
links :: [((Int, Int), (Int, Int))]
λ> :t rewire
rewire :: Tensors -> ((Int, Int), (Int, Int)) -> Maybe Tensors
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> links = p1UpdatesLHS (0, t0)
λ> :t rewire
rewire
  :: Maybe Tensors -> [((Int, Int), (Int, Int))] -> Maybe Tensors
λ> rewire (Just dumbellTensors) links
Just (Tensors (fromList [(0,Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)]))]))
λ> dumbellTensors
Tensors (fromList [(0,Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)]))])
λ> links = p1UpdatesRHS (0, t0)

<interactive>:5436:26-27: error:
    • Couldn't match expected type ‘(Int, Tensor)’
                  with actual type ‘Tensor’
    • In the expression: t0
      In the first argument of ‘p1UpdatesRHS’, namely ‘(0, t0)’
      In the expression: p1UpdatesRHS (0, t0)
λ> links = p1UpdatesRHS ((0,t0),(1,t1))
λ> links
[((0,1),(0,0)),((1,2),(1,1))]
λ> rewire (Just dumbellTensors) links
Just (Tensors (fromList [(0,Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)]))]))
λ> t0
Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])
λ> rewireSingle ((0,0),(1,0)) dumbellTensors

<interactive>:5445:28-41: error:
    • Couldn't match expected type ‘Maybe Tensors’
                  with actual type ‘Tensors’
    • In the second argument of ‘rewireSingle’, namely ‘dumbellTensors’
      In the expression: rewireSingle ((0, 0), (1, 0)) dumbellTensors
      In an equation for ‘it’:
          it = rewireSingle ((0, 0), (1, 0)) dumbellTensors
λ> rewireSingle ((0,0),(1,0)) (Just dumbellTensors)
Just (Tensors (fromList [(0,Tensor (fromList [(0,Pointer (1,0) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)]))]))
λ> rewireDual ((0,0),(1,0)) (Just dumbellTensors)

<interactive>:5447:12-24: error:
    • Couldn't match expected type ‘Tensors’
                  with actual type ‘((Integer, Integer), (Integer, Integer))’
    • In the first argument of ‘rewireDual’, namely ‘((0, 0), (1, 0))’
      In the expression:
        rewireDual ((0, 0), (1, 0)) (Just dumbellTensors)
      In an equation for ‘it’:
          it = rewireDual ((0, 0), (1, 0)) (Just dumbellTensors)

<interactive>:5447:27-45: error:
    • Couldn't match expected type ‘((Int, Int), (Int, Int))’
                  with actual type ‘Maybe Tensors’
    • In the second argument of ‘rewireDual’, namely
        ‘(Just dumbellTensors)’
      In the expression:
        rewireDual ((0, 0), (1, 0)) (Just dumbellTensors)
      In an equation for ‘it’:
          it = rewireDual ((0, 0), (1, 0)) (Just dumbellTensors)
λ> rewireDual ((0,0),(1,0)) (dumbellTensors)

<interactive>:5448:12-24: error:
    • Couldn't match expected type ‘Tensors’
                  with actual type ‘((Integer, Integer), (Integer, Integer))’
    • In the first argument of ‘rewireDual’, namely ‘((0, 0), (1, 0))’
      In the expression: rewireDual ((0, 0), (1, 0)) (dumbellTensors)
      In an equation for ‘it’:
          it = rewireDual ((0, 0), (1, 0)) (dumbellTensors)

<interactive>:5448:27-40: error:
    • Couldn't match expected type ‘((Int, Int), (Int, Int))’
                  with actual type ‘Tensors’
    • In the second argument of ‘rewireDual’, namely ‘(dumbellTensors)’
      In the expression: rewireDual ((0, 0), (1, 0)) (dumbellTensors)
      In an equation for ‘it’:
          it = rewireDual ((0, 0), (1, 0)) (dumbellTensors)
λ> rewireDual dumbellTensors ((0,0),(1,0))
Just (Tensors (fromList [(0,Tensor (fromList [(0,Pointer (1,0) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,0) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)]))]))
λ> rewire (Just dumbellTensors) ((0,0),(1,0))

<interactive>:5451:30-42: error:
    • Couldn't match expected type ‘[((Int, Int), (Int, Int))]’
                  with actual type ‘((Integer, Integer), (Integer, Integer))’
    • In the second argument of ‘rewire’, namely ‘((0, 0), (1, 0))’
      In the expression: rewire (Just dumbellTensors) ((0, 0), (1, 0))
      In an equation for ‘it’:
          it = rewire (Just dumbellTensors) ((0, 0), (1, 0))
λ> rewire (Just dumbellTensors) [((0,0),(1,0))]
Just (Tensors (fromList [(0,Tensor (fromList [(0,Pointer (1,0) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,0) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)]))]))
λ> rewire (Just dumbellTensors) [((0,0),(1,0)), ((0,0),(1,0))]
Just (Tensors (fromList [(0,Tensor (fromList [(0,Pointer (1,0) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,0) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)]))]))
λ> rewire (Just dumbellTensors) [((0,0),(1,2)), ((0,1),(1,1))]
Just (Tensors (fromList [(0,Tensor (fromList [(0,Pointer (1,2) Down),(1,Pointer (1,1) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (0,1) Down),(2,Pointer (0,0) Up)]))]))
λ> p1UpdatesLHS dumbellTensors

<interactive>:5457:14-27: error:
    • Couldn't match expected type ‘(Int, Tensor)’
                  with actual type ‘Tensors’
    • In the first argument of ‘p1UpdatesLHS’, namely ‘dumbellTensors’
      In the expression: p1UpdatesLHS dumbellTensors
      In an equation for ‘it’: it = p1UpdatesLHS dumbellTensors
λ> p1UpdatesLHS (0, t0)
[((0,0),(0,1)),((0,1),(0,0))]
λ> sunP1Link dumbellTensors
Just ((0,Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)])))
λ> sunP1 t0 t1
True
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> p1UpdatesLHS ((0,t0),(1,t1))
[((0,0),(1,1)),((0,1),(1,2))]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> p1UpdatesLHS ((0,t0),(1,t1))
[((0,0),(1,2)),((0,1),(1,1))]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> p1UpdatesLHS ((0,t0),(1,t1))
[((0,0),(1,1))]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> p1UpdatesLHS ((0,t0),(1,t1))
[((0,0),(1,2)),((0,0),(1,1))]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> p1UpdatesLHS ((0,t0),(1,t1))
[((0,0),(1,2)),((0,0),(1,1)),((0,1),(0,2))]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> p1UpdatesLHS ((0,t0),(1,t1))
[((0,0),(1,2)),((0,0),(1,1))]
λ> links = p1UpdatesLHS ((0, t0),(1, t1))
λ> rewire (Just dumbellTensors) links
Just (Tensors (fromList [(0,Tensor (fromList [(0,Pointer (1,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (0,0) Down),(2,Pointer (0,0) Up)]))]))
λ> links
[((0,0),(1,2)),((0,0),(1,1))]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> links = p1UpdatesLHS ((0, t0),(1, t1))
λ> links
[((0,0),(1,2))]
λ> links = p1UpdatesLHS ((0, t0),(1, t1))
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> links = p1UpdatesLHS ((0, t0),(1, t1))
λ> links
[((0,0),(1,1)),((0,1),(1,2))]
λ> rewire (Just dumbellTensors) links
Just (Tensors (fromList [(0,Tensor (fromList [(0,Pointer (1,1) Down),(1,Pointer (1,2) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (0,0) Down),(2,Pointer (0,1) Up)]))]))
λ> links
[((0,0),(1,1)),((0,1),(1,2))]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> links

<interactive>:5495:1-5: error:
    • Variable not in scope: links
    • Perhaps you meant ‘lines’ (imported from Data.List)
λ> links = p1UpdatesLHS ((0, t0),(1, t1))
λ> links
[((0,0),(1,2)),((0,1),(1,1))]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> p1UpdatesLHS ((0, t0),(1, t1))
[(Down,Down),(Up,Up)]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> p1UpdatesLHS ((0, t0),(1, t1))
[(Down,Up),(Up,Down)]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> p1UpdatesLHS ((0, t0),(1, t1))
[((0,0),(1,1)),((0,1),(1,2))]
λ> p1UpdatesLHS ((0, t0),(1, t1))
[((0,0),(1,1)),((0,1),(1,2))]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> p1UpdatesLHS ((0, t0),(1, t1))
[(Down,Down),(Up,Up)]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> p1UpdatesLHS ((0, t0),(1, t1))
[(Down,Up),(Up,Down)]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> p1UpdatesLHS ((0, t0),(1, t1))
[((Down,0,1),(Up,1,1)),((Up,0,0),(Down,1,2))]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> p1UpdatesLHS ((0, t0),(1, t1))
[((0,0),(1,2)),((0,1),(1,1))]
λ> links = p1UpdatesLHS ((0, t0),(1, t1))
λ> rewire (Just dumbellTensors) links
Just (Tensors (fromList [(0,Tensor (fromList [(0,Pointer (1,2) Down),(1,Pointer (1,1) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (0,1) Down),(2,Pointer (0,0) Up)]))]))
λ> p1UpdatesRHS ((0,t0),(1,t1))
[((0,1),(0,0)),((1,2),(1,1))]
λ> links = p1UpdatesRHS ((0,t0),(1,t1))
λ> rewire (Just dumbellTensors) links
Just (Tensors (fromList [(0,Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)]))]))
λ> sunP1 dumbell

<interactive>:5520:7-13: error:
    • Couldn't match expected type ‘Tensor’
                  with actual type ‘VectorSpace’
    • In the first argument of ‘sunP1’, namely ‘dumbell’
      In the expression: sunP1 dumbell
      In an equation for ‘it’: it = sunP1 dumbell
λ> sunP1Link dumbellTensors
Just ((0,Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)])))
λ> l = sunP1Link dumbellTensors
λ> length l
1
λ> :t l
l :: Maybe ((Int, Tensor), (Int, Tensor))
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> rewire (Just dumbellTensors) (sunP1Link dumbellTensors)

<interactive>:5533:31-54: error:
    • Couldn't match type ‘((Int, Tensor), (Int, Tensor))’
                     with ‘[((Int, Int), (Int, Int))]’
      Expected type: Maybe [((Int, Int), (Int, Int))]
        Actual type: Maybe ((Int, Tensor), (Int, Tensor))
    • In the second argument of ‘rewire’, namely
        ‘(sunP1Link dumbellTensors)’
      In the expression:
        rewire (Just dumbellTensors) (sunP1Link dumbellTensors)
      In an equation for ‘it’:
          it = rewire (Just dumbellTensors) (sunP1Link dumbellTensors)
λ> sunP1Link dumbellTensors
Just ((0,Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)])))
λ> p1UpdatesLHS $ sunP1Link dumbellTensors

<interactive>:5538:16-39: error:
    • Couldn't match expected type ‘((Int, Tensor), (Int, Tensor))’
                  with actual type ‘Maybe ((Int, Tensor), (Int, Tensor))’
    • In the second argument of ‘($)’, namely
        ‘sunP1Link dumbellTensors’
      In the expression: p1UpdatesLHS $ sunP1Link dumbellTensors
      In an equation for ‘it’:
          it = p1UpdatesLHS $ sunP1Link dumbellTensors
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> p1UpdatesLHS $ sunP1Link dumbellTensors
Just [((0,0),(1,2)),((0,1),(1,1))]
λ> rewire dumbellTensors (p1UpdatesLHS $ sunP1Link dumbellTensors)

<interactive>:5542:8-21: error:
    • Couldn't match expected type ‘Maybe Tensors’
                  with actual type ‘Tensors’
    • In the first argument of ‘rewire’, namely ‘dumbellTensors’
      In the expression:
        rewire dumbellTensors (p1UpdatesLHS $ sunP1Link dumbellTensors)
      In an equation for ‘it’:
          it
            = rewire dumbellTensors (p1UpdatesLHS $ sunP1Link dumbellTensors)
λ> rewire (Just dumbellTensors) (p1UpdatesLHS $ sunP1Link dumbellTensors)
Just (Tensors (fromList [(0,Tensor (fromList [(0,Pointer (1,2) Down),(1,Pointer (1,1) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (0,1) Down),(2,Pointer (0,0) Up)]))]))
λ> fromCoeffs [0]
LaurentPolynomial.Cons 0 [0]
λ> fromCoeffs [1]
LaurentPolynomial.Cons 0 [1]
λ> fromCoeffs [3]
LaurentPolynomial.Cons 0 [3]
λ> fromCoeffs [0,1,0]
LaurentPolynomial.Cons 0 [0,1,0]
λ> x = fromCoeffs [0,1,0]
λ> x + x

<interactive>:5551:1-5: error:
    • Non type-variable argument in the constraint: Num (T a)
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        it :: forall a. (Num a, Num (T a)) => T a
λ> y = x + x

<interactive>:5552:1-9: error:
    • Non type-variable argument in the constraint: Num (T a)
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        y :: forall a. (Num a, Num (T a)) => T a
λ> add x x
LaurentPolynomial.Cons 0 [0,2,0]
λ> mul x x
LaurentPolynomial.Cons 0 [0,0,1,0,0]
λ> mul (mul x x) x
LaurentPolynomial.Cons 0 [0,0,0,1,0,0,0]
λ> x = fromShiftCoeffs -1 [1]

<interactive>:5558:1-26: error:
    • Non type-variable argument
        in the constraint: Num ([a1] -> Int -> [a2] -> T a2)
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        x :: forall a1 a2.
             (Num a1, Num ([a1] -> Int -> [a2] -> T a2),
              Num (Int -> [a2] -> T a2)) =>
             Int -> [a2] -> T a2
λ> x = fromShiftCoeffs -1 [1]

<interactive>:5561:1-26: error:
    • Non type-variable argument
        in the constraint: Num ([a1] -> Int -> [a2] -> T a2)
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        x :: forall a1 a2.
             (Num a1, Num ([a1] -> Int -> [a2] -> T a2),
              Num (Int -> [a2] -> T a2)) =>
             Int -> [a2] -> T a2
λ> shift 1 (fromCoeffs [1])
LaurentPolynomial.Cons 1 [1]
λ> shift -1 (fromCoeffs [1])

<interactive>:5564:1-25: error:
    • Non type-variable argument
        in the constraint: Num (T a1 -> Int -> T a2 -> T a2)
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        it :: forall a1 a2.
              (Num a1, Num (T a1 -> Int -> T a2 -> T a2),
               Num (Int -> T a2 -> T a2)) =>
              Int -> T a2 -> T a2
λ> div (fromCoeffs [1]) (fromCoeffs [0,1])

<interactive>:5568:1-3: error:
    Ambiguous occurrence ‘div’
    It could refer to either ‘Prelude.div’,
                             imported from ‘Prelude’ at tensor-map.hs:1:1
                             (and originally defined in ‘GHC.Real’)
                          or ‘LP.div’,
                             imported from ‘MathObj.LaurentPolynomial’ at tensor-map.hs:3:1-38
λ> LP.div (fromCoeffs [1]) (fromCoeffs [0,1])
LaurentPolynomial.Cons -1 [1.0]
λ> shift (-1) (fromCoeffs [1])
LaurentPolynomial.Cons -1 [1]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> decomposeP1 dumbell
[TensorProduct (LaurentPolynomial.Cons 0 [1]) (Tensors (fromList [(0,Tensor (fromList [(0,Pointer (1,2) Down),(1,Pointer (1,1) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (0,1) Down),(2,Pointer (0,0) Up)]))])),TensorProduct (LaurentPolynomial.Cons -1 [1]) (Tensors (fromList [(0,Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)]))]))]
λ> : concat
Syntax: :complete repl [<range>] <quoted-string-to-complete>
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> decomposeP1 dumbell
*** Exception: Tensor.hs:130:1-83: Non-exhaustive patterns in function updatePointerAt

λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )

Tensor.hs:177:22-28: error:
    • Couldn't match expected type ‘[a]’ with actual type ‘Maybe a0’
    • In the expression: Nothing
      In an equation for ‘vsIDXsToWipe’: vsIDXsToWipe _ = Nothing
      In an equation for ‘decomposeP1’:
          decomposeP1 (TensorProduct _ tensors)
            = v0 ++ v1
            where
                link = sunP1Link tensors
                updatesLHS = p1UpdatesLHS link
                updatesRHS = p1UpdatesRHS link
                fromVSIDXs updates = [from | ((from, _), _) <- updates]
                ....
    • Relevant bindings include
        vsIDXsToWipe :: Maybe [((a, b), (a, b1))] -> [a]
          (bound at Tensor.hs:176:5)
    |
177 |     vsIDXsToWipe _ = Nothing
    |                      ^^^^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> decomposeP1 dumbell
*** Exception: Tensor.hs:130:1-83: Non-exhaustive patterns in function updatePointerAt

λ> putStrLn "hello"
hello
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> putStrLn "hello"
hello
λ> decomposeP1 dumbell
[]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> decomposeP1 dumbell
[]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )

Tensor.hs:191:1-4: error:
    Parse error: module header, import declaration
    or top-level declaration expected.
    |
191 | main
    | ^^^^
Failed, no modules loaded.
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> decomposeP1 dumbell
[TensorProduct (LaurentPolynomial.Cons 0 [1]) (Tensors (fromList [(0,Tensor (fromList [(0,Pointer (1,2) Down),(1,Pointer (1,1) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (0,1) Down),(2,Pointer (0,0) Up)]))]))]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> decomposeP1 dumbell
[TensorProduct (LaurentPolynomial.Cons 0 [1]) (Tensors (fromList [(0,Tensor (fromList [(0,Pointer (1,2) Down),(1,Pointer (1,1) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (0,1) Down),(2,Pointer (0,0) Up)]))]))]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )

Tensor.hs:131:1-55: warning: [-Woverlapping-patterns]
    Pattern match is redundant
    In an equation for ‘updatePointerAt’:
        updatePointerAt (Just (Pointer _ edgeType)) _ = ...
    |
131 | updatePointerAt (Just (Pointer _ edgeType)) _ = Nothing
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> decomposeP1 dumbell
*** Exception: Tensor.hs:(130,1)-(131,55): Non-exhaustive patterns in function updatePointerAt

λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> decomposeP1 dumbell
[]
λ> link = sunP1Link dumbellTensors
λ> link
Just ((0,Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)])))
λ> p1UpdatesLHS link
Just [((0,0),(1,2)),((0,1),(1,1))]
λ> fromVSIDXs updates = [ from | ((from, _), _) <- updates]
λ> updates LHS = p1UpdatesLHS link

<interactive>:5607:9-11: error:
    Not in scope: data constructor ‘LHS’
λ> updatesLHS = p1UpdatesLHS link
λ> updatesLHS
Just [((0,0),(1,2)),((0,1),(1,1))]
λ> fromVSIDXs updatesLHS

<interactive>:5612:12-21: error:
    • Couldn't match expected type ‘[((a, b10), b20)]’
                  with actual type ‘Maybe [((Int, Int), (Int, Int))]’
    • In the first argument of ‘fromVSIDXs’, namely ‘updatesLHS’
      In the expression: fromVSIDXs updatesLHS
      In an equation for ‘it’: it = fromVSIDXs updatesLHS
    • Relevant bindings include
        it :: [a] (bound at <interactive>:5612:1)
λ> fromVSIDXs (Just updates) = [ from | ((from, _), _) <- updates]
λ> fromVSIDXs updatesLHS
[0,0]
λ> fromVSIDXs (Just updates) = [ from | ((from, _), _) <- updates]
λ> toVSIDXs (Just updates) = [ to | (_, (to, _)) <- updates]
λ> vsIDXsToWipe updates = (fromVSIDXs updates) ++ (toVSIDXs updates)
λ> vsIDXsToWipe updatesLHS
[0,0,1,1]
λ> vsIDXsToWipe updates = nub $ (fromVSIDXs updates) ++ (toVSIDXs updates)
λ> vsIDXsToWipe updatesLHS
[0,1]
λ> vsIDXsToWipe updatesLHS
[0,1]
λ> wipeTensors tensors (vsIDXsToWipe updatesLHS)

<interactive>:5626:13-19: error:
    • Variable not in scope: tensors :: Tensors
    • Perhaps you meant one of these:
        data constructor ‘Tensors’ (imported from Tensor),
        data constructor ‘Tensor’ (imported from Tensor)
λ> wipeTensors dumbellTensors (vsIDXsToWipe updatesLHS)
Tensors (fromList [(0,Tensor (fromList [])),(1,Tensor (fromList []))])
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> decomposeP1 dumbell
[]
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )

Tensor.hs:184:56-58: error:
    • Couldn't match expected type ‘Tensors’
                  with actual type ‘Maybe Tensors’
    • In the second argument of ‘TensorProduct’, namely ‘lhs’
      In the expression: TensorProduct (fromCoeffs [1]) lhs
      In the expression: [TensorProduct (fromCoeffs [1]) lhs]
    |
184 |       Just tensors -> [TensorProduct  (fromCoeffs [1]) lhs]
    |                                                        ^^^
Failed, no modules loaded.
λ> wipeTensors dumbellTensors (vsIDXsToWipe updatesLHS)

<interactive>:5636:1-11: error:
    Variable not in scope: wipeTensors :: t0 -> t1 -> t

<interactive>:5636:13-26: error:
    Variable not in scope: dumbellTensors

<interactive>:5636:29-40: error:
    Variable not in scope: vsIDXsToWipe :: t2 -> t1

<interactive>:5636:42-51: error: Variable not in scope: updatesLHS
λ> :l ten
target ‘ten’ is not a module name or a source file
λ> :l tensor-map.hs
[1 of 2] Compiling Tensor           ( Tensor.hs, interpreted )
[2 of 2] Compiling Main             ( tensor-map.hs, interpreted )
Ok, two modules loaded.
Collecting type info for 2 module(s) ... 
λ> wipeTensors dumbellTensors (vsIDXsToWipe updatesLHS)

<interactive>:5640:29-40: error:
    Variable not in scope: vsIDXsToWipe :: t0 -> [Int]

<interactive>:5640:42-51: error:
    • Variable not in scope: updatesLHS
    • Perhaps you meant ‘p1UpdatesLHS’ (imported from Tensor)
λ> wipeTensors dumbellTensors (vsIDXsToWipe updatesLHS)

<interactive>:5641:29-40: error:
    Variable not in scope: vsIDXsToWipe :: t0 -> [Int]

<interactive>:5641:42-51: error:
    • Variable not in scope: updatesLHS
    • Perhaps you meant ‘p1UpdatesLHS’ (imported from Tensor)
λ> dumbellTensors
Tensors (fromList [(0,Tensor (fromList [(0,Pointer (0,1) Down),(1,Pointer (0,0) Up),(2,Pointer (1,0) Gluon)])),(1,Tensor (fromList [(0,Pointer (0,2) Gluon),(1,Pointer (1,2) Down),(2,Pointer (1,1) Up)]))])
λ> wipeTensors dumbellTensors (vsIDXsToWipe updatesLHS)
    fromVSIDXs (Just updates) = [ from | ((from, _), _) <- updates]
    toVSIDXs (Just updates) = [ to | (_, (to, _)) <- updates]
    vsIDXsToWipe updates = nub $ (fromVSIDXs updates) ++ (toVSIDXs updates)
Some flags have not been recognized: prompt2, 
*Main Data.Map Data.List| *Main Data.Map Data.List| *Main Data.Map Data.List| *Main Data.Map Data.List| *Main Data.Map Data.List| 
<interactive>:5646:29-51: error:
    Parse error in pattern: vsIDXsToWipe
Some flags have not been recognized: prompt2, λ| 
λ> 
    fromVSIDXs (Just updates) = [ from | ((from, _), _) <- updates]
    toVSIDXs (Just updates) = [ to | (_, (to, _)) <- updates]
    vsIDXsToWipe updates = nub $ (fromVSIDXs updates) ++ (toVSIDXs updates)
Some flags have not been recognized: prompt2, 
*Main Data.Map Data.List| *Main Data.Map Data.List| *Main Data.Map Data.List| *Main Data.Map Data.List| *Main Data.Map Data.List| Some flags have not been recognized: prompt2, λ| 
λ> fromVSIDXs (Just updates) = [ from | ((from, _), _) <- updates]
λ> toVSIDXs (Just updates) = [ to | (_, (to, _)) <- updates]
λ> vsIDXsToWipe updates = nub $ (fromVSIDXs updates) ++ (toVSIDXs updates)
λ> wipeTensors tensors (vsIDXsToWipe updatesLHS)

<interactive>:5664:13-19: error:
    • Variable not in scope: tensors :: Tensors
    • Perhaps you meant one of these:
        data constructor ‘Tensors’ (imported from Tensor),
        data constructor ‘Tensor’ (imported from Tensor)

<interactive>:5664:35-44: error:
    • Variable not in scope:
        updatesLHS :: Maybe [((Int, b10), (Int, b0))]
    • Perhaps you meant ‘p1UpdatesLHS’ (imported from Tensor)
λ> wipeTensors tensors (vsIDXsToWipe updatesLHS)wipeTensors tensors (vsIDXsToWipe updatesLHS)

<interactive>:5672:13-19: error:
    • Variable not in scope: tensors :: Tensors
    • Perhaps you meant one of these:
        data constructor ‘Tensors’ (imported from Tensor),
        data constructor ‘Tensor’ (imported from Tensor)
λ> wipeTensors tensors (vsIDXsToWipe updatesLHS)

<interactive>:5673:13-19: error:
    • Variable not in scope: tensors :: Tensors
    • Perhaps you meant one of these:
        data constructor ‘Tensors’ (imported from Tensor),
        data constructor ‘Tensor’ (imported from Tensor)
λ> wipeTensors dumbellTensors (vsIDXsToWipe updatesLHS)
Tensors (fromList [(0,Tensor (fromList [])),(1,Tensor (fromList []))])
λ> 